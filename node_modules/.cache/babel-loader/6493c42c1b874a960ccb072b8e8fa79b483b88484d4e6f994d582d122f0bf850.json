{"ast":null,"code":"/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\nPoint.prototype = {\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  },\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add(p) {\n    return this.clone()._add(p);\n  },\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub(p) {\n    return this.clone()._sub(p);\n  },\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint(p) {\n    return this.clone()._multByPoint(p);\n  },\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint(p) {\n    return this.clone()._divByPoint(p);\n  },\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {number} k factor\n   * @return {Point} output point\n   */\n  mult(k) {\n    return this.clone()._mult(k);\n  },\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {number} k factor\n   * @return {Point} output point\n   */\n  div(k) {\n    return this.clone()._div(k);\n  },\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate(a) {\n    return this.clone()._rotate(a);\n  },\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround(a, p) {\n    return this.clone()._rotateAround(a, p);\n  },\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {[number, number, number, number]} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult(m) {\n    return this.clone()._matMult(m);\n  },\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit() {\n    return this.clone()._unit();\n  },\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp() {\n    return this.clone()._perp();\n  },\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round() {\n    return this.clone()._round();\n  },\n  /**\n   * Return the magnitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {number} magnitude\n   */\n  mag() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  },\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {number} distance\n   */\n  dist(p) {\n    return Math.sqrt(this.distSqr(p));\n  },\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {number} distance\n   */\n  distSqr(p) {\n    const dx = p.x - this.x,\n      dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  },\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {number} angle\n   */\n  angle() {\n    return Math.atan2(this.y, this.x);\n  },\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {number} angle\n   */\n  angleTo(b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  },\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {number} angle\n   */\n  angleWith(b) {\n    return this.angleWithSep(b.x, b.y);\n  },\n  /**\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin(θ) for θ.\n   * @param {number} x the x-coordinate\n   * @param {number} y the y-coordinate\n   * @return {number} the angle in radians\n   */\n  angleWithSep(x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  },\n  /** @param {[number, number, number, number]} m */\n  _matMult(m) {\n    const x = m[0] * this.x + m[1] * this.y,\n      y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  /** @param {Point} p */\n  _add(p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  },\n  /** @param {Point} p */\n  _sub(p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  },\n  /** @param {number} k */\n  _mult(k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  },\n  /** @param {number} k */\n  _div(k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  },\n  /** @param {Point} p */\n  _multByPoint(p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  },\n  /** @param {Point} p */\n  _divByPoint(p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  },\n  _unit() {\n    this._div(this.mag());\n    return this;\n  },\n  _perp() {\n    const y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  },\n  /** @param {number} angle */\n  _rotate(angle) {\n    const cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      x = cos * this.x - sin * this.y,\n      y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  /**\n   * @param {number} angle\n   * @param {Point} p\n   */\n  _rotateAround(angle, p) {\n    const cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n      y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  },\n  constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n  if (p instanceof Point) {\n    return /** @type {Point} */p;\n  }\n  if (Array.isArray(p)) {\n    return new Point(+p[0], +p[1]);\n  }\n  if (p.x !== undefined && p.y !== undefined) {\n    return new Point(+p.x, +p.y);\n  }\n  throw new Error('Expected [x, y] or {x, y} point format');\n};","map":{"version":3,"names":["Point","x","y","prototype","clone","add","p","_add","sub","_sub","multByPoint","_multByPoint","divByPoint","_divByPoint","mult","k","_mult","div","_div","rotate","a","_rotate","rotateAround","_rotateAround","matMult","m","_matMult","unit","_unit","perp","_perp","round","_round","mag","Math","sqrt","equals","other","dist","distSqr","dx","dy","angle","atan2","angleTo","b","angleWith","angleWithSep","cos","sin","constructor","convert","Array","isArray","undefined","Error"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@mapbox/mapbox-gl-draw/node_modules/@mapbox/point-geometry/index.js"],"sourcesContent":["/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}