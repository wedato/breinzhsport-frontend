{"ast":null,"code":"'use strict';\n\nvar $TypeError = require('es-errors/type');\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar TypedArrayElementSize = require('./TypedArrayElementSize');\nvar isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\nvar typedArrayLength = require('typed-array-length');\n\n// https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds\n\nmodule.exports = function IsTypedArrayOutOfBounds(taRecord) {\n  if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {\n    throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');\n  }\n  var O = taRecord['[[Object]]']; // step 1\n\n  var bufferByteLength = taRecord['[[CachedBufferByteLength]]']; // step 2\n\n  if (IsDetachedBuffer(typedArrayBuffer(O)) && bufferByteLength !== 'DETACHED') {\n    throw new $TypeError('Assertion failed: typed array is detached only if the byte length is ~DETACHED~'); // step 3\n  }\n  if (bufferByteLength === 'DETACHED') {\n    return true; // step 4\n  }\n  var byteOffsetStart = typedArrayByteOffset(O); // step 5\n\n  var byteOffsetEnd;\n  var length = typedArrayLength(O);\n  // TODO: probably use package for array length\n  // seems to apply when TA is backed by a resizable/growable AB\n  if (length === 'AUTO') {\n    // step 6\n    byteOffsetEnd = bufferByteLength; // step 6.a\n  } else {\n    var elementSize = TypedArrayElementSize(O); // step 7.a\n\n    byteOffsetEnd = byteOffsetStart + length * elementSize; // step 7.b\n  }\n  if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {\n    return true; // step 8\n  }\n\n  // 9. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n\n  return false; // step 10\n};","map":{"version":3,"names":["$TypeError","require","IsDetachedBuffer","TypedArrayElementSize","isTypedArrayWithBufferWitnessRecord","typedArrayBuffer","typedArrayByteOffset","typedArrayLength","module","exports","IsTypedArrayOutOfBounds","taRecord","O","bufferByteLength","byteOffsetStart","byteOffsetEnd","length","elementSize"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/es-abstract/2024/IsTypedArrayOutOfBounds.js"],"sourcesContent":["'use strict';\n\nvar $TypeError = require('es-errors/type');\n\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar TypedArrayElementSize = require('./TypedArrayElementSize');\n\nvar isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');\n\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\nvar typedArrayLength = require('typed-array-length');\n\n// https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds\n\nmodule.exports = function IsTypedArrayOutOfBounds(taRecord) {\n\tif (!isTypedArrayWithBufferWitnessRecord(taRecord)) {\n\t\tthrow new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');\n\t}\n\n\tvar O = taRecord['[[Object]]']; // step 1\n\n\tvar bufferByteLength = taRecord['[[CachedBufferByteLength]]']; // step 2\n\n\tif (IsDetachedBuffer(typedArrayBuffer(O)) && bufferByteLength !== 'DETACHED') {\n\t\tthrow new $TypeError('Assertion failed: typed array is detached only if the byte length is ~DETACHED~'); // step 3\n\t}\n\n\tif (bufferByteLength === 'DETACHED') {\n\t\treturn true; // step 4\n\t}\n\n\tvar byteOffsetStart = typedArrayByteOffset(O); // step 5\n\n\tvar byteOffsetEnd;\n\tvar length = typedArrayLength(O);\n\t// TODO: probably use package for array length\n\t// seems to apply when TA is backed by a resizable/growable AB\n\tif (length === 'AUTO') { // step 6\n\t\tbyteOffsetEnd = bufferByteLength; // step 6.a\n\t} else {\n\t\tvar elementSize = TypedArrayElementSize(O); // step 7.a\n\n\t\tbyteOffsetEnd = byteOffsetStart + (length * elementSize); // step 7.b\n\t}\n\n\tif (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {\n\t\treturn true; // step 8\n\t}\n\n\t// 9. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n\n\treturn false; // step 10\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,UAAU,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAE1C,IAAIC,gBAAgB,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AACpD,IAAIE,qBAAqB,GAAGF,OAAO,CAAC,yBAAyB,CAAC;AAE9D,IAAIG,mCAAmC,GAAGH,OAAO,CAAC,2DAA2D,CAAC;AAE9G,IAAII,gBAAgB,GAAGJ,OAAO,CAAC,oBAAoB,CAAC;AACpD,IAAIK,oBAAoB,GAAGL,OAAO,CAAC,yBAAyB,CAAC;AAC7D,IAAIM,gBAAgB,GAAGN,OAAO,CAAC,oBAAoB,CAAC;;AAEpD;;AAEAO,MAAM,CAACC,OAAO,GAAG,SAASC,uBAAuBA,CAACC,QAAQ,EAAE;EAC3D,IAAI,CAACP,mCAAmC,CAACO,QAAQ,CAAC,EAAE;IACnD,MAAM,IAAIX,UAAU,CAAC,8EAA8E,CAAC;EACrG;EAEA,IAAIY,CAAC,GAAGD,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC;;EAEhC,IAAIE,gBAAgB,GAAGF,QAAQ,CAAC,4BAA4B,CAAC,CAAC,CAAC;;EAE/D,IAAIT,gBAAgB,CAACG,gBAAgB,CAACO,CAAC,CAAC,CAAC,IAAIC,gBAAgB,KAAK,UAAU,EAAE;IAC7E,MAAM,IAAIb,UAAU,CAAC,iFAAiF,CAAC,CAAC,CAAC;EAC1G;EAEA,IAAIa,gBAAgB,KAAK,UAAU,EAAE;IACpC,OAAO,IAAI,CAAC,CAAC;EACd;EAEA,IAAIC,eAAe,GAAGR,oBAAoB,CAACM,CAAC,CAAC,CAAC,CAAC;;EAE/C,IAAIG,aAAa;EACjB,IAAIC,MAAM,GAAGT,gBAAgB,CAACK,CAAC,CAAC;EAChC;EACA;EACA,IAAII,MAAM,KAAK,MAAM,EAAE;IAAE;IACxBD,aAAa,GAAGF,gBAAgB,CAAC,CAAC;EACnC,CAAC,MAAM;IACN,IAAII,WAAW,GAAGd,qBAAqB,CAACS,CAAC,CAAC,CAAC,CAAC;;IAE5CG,aAAa,GAAGD,eAAe,GAAIE,MAAM,GAAGC,WAAY,CAAC,CAAC;EAC3D;EAEA,IAAIH,eAAe,GAAGD,gBAAgB,IAAIE,aAAa,GAAGF,gBAAgB,EAAE;IAC3E,OAAO,IAAI,CAAC,CAAC;EACd;;EAEA;;EAEA,OAAO,KAAK,CAAC,CAAC;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}