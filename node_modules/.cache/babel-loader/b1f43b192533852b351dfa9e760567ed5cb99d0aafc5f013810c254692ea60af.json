{"ast":null,"code":"\"use strict\";\n\nvar crypto = require('crypto');\nvar CapturedException = require('./captured_exception');\nvar RemoteRequestData = require('./remote_request_data');\nvar SegmentEmitter = require('../../segment_emitter');\nvar SegmentUtils = require('../segment_utils');\nvar Utils = require('../../utils');\nvar logger = require('../../logger');\n/**\n * Represents a subsegment.\n * @constructor\n * @param {string} name - The name of the subsegment.\n */\nfunction Subsegment(name) {\n  this.init(name);\n}\nSubsegment.prototype.init = function init(name) {\n  if (typeof name != 'string') {\n    throw new Error('Subsegment name must be of type string.');\n  }\n  this.id = crypto.randomBytes(8).toString('hex');\n  this.name = name;\n  this.start_time = SegmentUtils.getCurrentTime();\n  this.in_progress = true;\n  this.counter = 0;\n  this.notTraced = false;\n};\n/**\n * Nests a new subsegment to the array of subsegments.\n * @param {string} name - The name of the new subsegment to append.\n * @returns {Subsegment} - The newly created subsegment.\n */\nSubsegment.prototype.addNewSubsegment = function addNewSubsegment(name) {\n  const subsegment = new Subsegment(name);\n  this.addSubsegment(subsegment);\n  return subsegment;\n};\nSubsegment.prototype.addSubsegmentWithoutSampling = function addSubsegmentWithoutSampling(subsegment) {\n  this.addSubsegment(subsegment);\n  subsegment.notTraced = true;\n};\nSubsegment.prototype.addNewSubsegmentWithoutSampling = function addNewSubsegmentWithoutSampling(name) {\n  const subsegment = new Subsegment(name);\n  this.addSubsegment(subsegment);\n  subsegment.notTraced = true;\n  return subsegment;\n};\n/**\n * Adds a subsegment to the array of subsegments.\n * @param {Subsegment} subsegment - The subsegment to append.\n */\nSubsegment.prototype.addSubsegment = function (subsegment) {\n  if (!(subsegment instanceof Subsegment)) {\n    throw new Error('Failed to add subsegment:' + subsegment + ' to subsegment \"' + this.name + '\".  Not a subsegment.');\n  }\n  if (this.subsegments === undefined) {\n    this.subsegments = [];\n  }\n  subsegment.segment = this.segment;\n  subsegment.parent = this;\n  subsegment.notTraced = subsegment.parent.notTraced;\n  subsegment.noOp = subsegment.parent.noOp;\n  if (subsegment.end_time === undefined) {\n    this.incrementCounter(subsegment.counter);\n  }\n  this.subsegments.push(subsegment);\n};\n/**\n * Removes the subsegment from the subsegments array, used in subsegment streaming.\n */\nSubsegment.prototype.removeSubsegment = function removeSubsegment(subsegment) {\n  if (!(subsegment instanceof Subsegment)) {\n    throw new Error('Failed to remove subsegment:' + subsegment + ' from subsegment \"' + this.name + '\".  Not a subsegment.');\n  }\n  if (this.subsegments !== undefined) {\n    var index = this.subsegments.indexOf(subsegment);\n    if (index >= 0) {\n      this.subsegments.splice(index, 1);\n    }\n  }\n};\n/**\n * Adds a property with associated data into the subsegment.\n * @param {string} name - The name of the property to add.\n * @param {Object} data - The data of the property to add.\n */\nSubsegment.prototype.addAttribute = function addAttribute(name, data) {\n  this[name] = data;\n};\n/**\n * Adds a subsegement id to record ordering.\n * @param {string} id - A subsegment id.\n */\nSubsegment.prototype.addPrecursorId = function (id) {\n  if (typeof id !== 'string') {\n    logger.getLogger().error('Failed to add id:' + id + ' to subsegment ' + this.name + '.  Precursor Ids must be of type string.');\n  }\n  if (this.precursor_ids === undefined) {\n    this.precursor_ids = [];\n  }\n  this.precursor_ids.push(id);\n};\n/**\n * Adds a key-value pair that can be queryable through GetTraceSummaries.\n * Only acceptable types are string, float/int and boolean.\n * @param {string} key - The name of key to add.\n * @param {boolean|string|number} value - The value to add for the given key.\n */\nSubsegment.prototype.addAnnotation = function (key, value) {\n  if (typeof value !== 'boolean' && typeof value !== 'string' && !isFinite(value)) {\n    logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Value must be of type string, number or boolean.');\n    return;\n  }\n  if (typeof key !== 'string') {\n    logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Key must be of type string.');\n    return;\n  }\n  if (this.annotations === undefined) {\n    this.annotations = {};\n  }\n  this.annotations[key] = value;\n};\n/**\n * Adds a key-value pair to the metadata.default attribute when no namespace is given.\n * Metadata is not queryable, but is recorded.\n * @param {string} key - The name of the key to add.\n * @param {object|null} value - The value of the associated key.\n * @param {string} [namespace] - The property name to put the key/value pair under.\n */\nSubsegment.prototype.addMetadata = function (key, value, namespace) {\n  if (typeof key !== 'string') {\n    logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Key must be of type string.');\n    return;\n  }\n  if (namespace && typeof namespace !== 'string') {\n    logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Namespace must be of type string.');\n    return;\n  }\n  var ns = namespace || 'default';\n  if (!this.metadata) {\n    this.metadata = {};\n  }\n  if (!this.metadata[ns]) {\n    this.metadata[ns] = {};\n  }\n  if (ns !== '__proto__') {\n    this.metadata[ns][key] = value !== null && value !== undefined ? value : '';\n  }\n};\nSubsegment.prototype.addSqlData = function addSqlData(sqlData) {\n  this.sql = sqlData;\n};\n/**\n * Adds an error with associated data into the subsegment.\n * To handle propagating errors, the subsegment also sets a copy of the error on the\n * root segment.  As the error passes up the execution stack, a reference is created\n * on each subsegment to the originating subsegment.\n * @param {Error|string} err - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSubsegment.prototype.addError = function addError(err, remote) {\n  if (err == null || typeof err !== 'object' && typeof err !== 'string') {\n    logger.getLogger().error('Failed to add error:' + err + ' to subsegment \"' + this.name + '\".  Not an object or string literal.');\n    return;\n  }\n  this.addFaultFlag();\n  if (this.segment && this.segment.exception) {\n    if (err === this.segment.exception.ex) {\n      this.fault = true;\n      this.cause = {\n        id: this.segment.exception.cause,\n        exceptions: []\n      };\n      return;\n    }\n    delete this.segment.exception;\n  }\n  if (this.segment) {\n    this.segment.exception = {\n      ex: err,\n      cause: this.id\n    };\n  } else {\n    //error, cannot propagate exception if not added to segment\n  }\n  if (this.cause === undefined) {\n    this.cause = {\n      working_directory: process.cwd(),\n      exceptions: []\n    };\n  }\n  this.cause.exceptions.unshift(new CapturedException(err, remote));\n};\n/**\n * Adds data for an outgoing HTTP/HTTPS call.\n * @param {http.ClientRequest/https.ClientRequest} req - The request object from the HTTP/HTTPS call.\n * @param {http.IncomingMessage/https.IncomingMessage} res - The response object from the HTTP/HTTPS call.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced\": true hint to generated subsegments such that the AWS X-Ray service expects a corresponding segment from the downstream service.\n */\nSubsegment.prototype.addRemoteRequestData = function addRemoteRequestData(req, res, downstreamXRayEnabled) {\n  this.http = new RemoteRequestData(req, res, downstreamXRayEnabled);\n  if ('traced' in this.http.request) {\n    this.traced = this.http.request.traced;\n    delete this.http.request.traced;\n  }\n};\n/**\n * Adds fault flag to the subsegment.\n */\nSubsegment.prototype.addFaultFlag = function addFaultFlag() {\n  this.fault = true;\n};\n/**\n * Adds error flag to the subsegment.\n */\nSubsegment.prototype.addErrorFlag = function addErrorFlag() {\n  this.error = true;\n};\n/**\n * Adds throttle flag to the subsegment.\n */\nSubsegment.prototype.addThrottleFlag = function addThrottleFlag() {\n  this.throttle = true;\n};\n/**\n * Closes the current subsegment.  This automatically captures any exceptions and sets the end time.\n * @param {Error|string} [err] - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSubsegment.prototype.close = function close(err, remote) {\n  var root = this.segment;\n  this.end_time = SegmentUtils.getCurrentTime();\n  delete this.in_progress;\n  if (err) {\n    this.addError(err, remote);\n  }\n  if (this.parent) {\n    this.parent.decrementCounter();\n  }\n  if (root && root.counter > SegmentUtils.getStreamingThreshold()) {\n    if (this.streamSubsegments() && this.parent) {\n      this.parent.removeSubsegment(this);\n    }\n  }\n};\n/**\n * Each subsegment holds a counter of open subsegments.  This increments\n * the counter such that it can be called from a child and propagate up.\n * @param {Number} [additional] - An additional amount to increment.  Used when adding subsegment trees.\n */\nSubsegment.prototype.incrementCounter = function incrementCounter(additional) {\n  this.counter = additional ? this.counter + additional + 1 : this.counter + 1;\n  if (this.parent) {\n    this.parent.incrementCounter(additional);\n  }\n};\n/**\n * Each subsegment holds a counter of its open subsegments.  This decrements\n * the counter such that it can be called from a child and propagate up.\n */\nSubsegment.prototype.decrementCounter = function decrementCounter() {\n  this.counter--;\n  if (this.parent) {\n    this.parent.decrementCounter();\n  }\n};\n/**\n * Returns a boolean indicating whether or not the subsegment has been closed.\n * @returns {boolean} - Returns true if the subsegment is closed.\n */\nSubsegment.prototype.isClosed = function isClosed() {\n  return !this.in_progress;\n};\n/**\n * Sends the subsegment to the daemon.\n */\nSubsegment.prototype.flush = function flush() {\n  if (!this.parent || !this.segment) {\n    logger.getLogger().error('Failed to flush subsegment: ' + this.name + '. Subsegment must be added ' + 'to a segment chain to flush.');\n    return;\n  }\n  if (this.segment.trace_id) {\n    if (this.segment.notTraced !== true && !this.notTraced) {\n      SegmentEmitter.send(this);\n    } else {\n      logger.getLogger().debug('Ignoring flush on subsegment ' + this.id + '. Associated segment is marked as not sampled.');\n    }\n  } else {\n    logger.getLogger().debug('Ignoring flush on subsegment ' + this.id + '. Associated segment is missing a trace ID.');\n  }\n};\n/**\n * Returns true if the subsegment was streamed in its entirety\n */\nSubsegment.prototype.streamSubsegments = function streamSubsegments() {\n  if (this.isClosed() && this.counter <= 0) {\n    this.flush();\n    return true;\n  } else if (this.subsegments && this.subsegments.length > 0) {\n    var open = [];\n    this.subsegments.forEach(function (child) {\n      if (!child.streamSubsegments()) {\n        open.push(child);\n      }\n    });\n    this.subsegments = open;\n  }\n};\n/**\n * Returns the formatted, trimmed subsegment JSON string to send to the daemon.\n */\nSubsegment.prototype.format = function format() {\n  this.type = 'subsegment';\n  if (this.parent) {\n    this.parent_id = this.parent.id;\n  }\n  if (this.segment) {\n    this.trace_id = this.segment.trace_id;\n  }\n  return this.serialize();\n};\n/**\n * Returns the formatted subsegment JSON string.\n */\nSubsegment.prototype.toString = function toString() {\n  return this.serialize();\n};\nSubsegment.prototype.toJSON = function toJSON() {\n  var ignore = ['segment', 'parent', 'counter'];\n  if (this.subsegments == null || this.subsegments.length === 0) {\n    ignore.push('subsegments');\n  }\n  var thisCopy = Utils.objectWithoutProperties(this, ignore, false);\n  return thisCopy;\n};\n/**\n * Returns the serialized subsegment JSON string, replacing any BigInts with strings.\n */\nSubsegment.prototype.serialize = function serialize(object) {\n  return JSON.stringify(object !== null && object !== void 0 ? object : this, SegmentUtils.getJsonStringifyReplacer());\n};\nmodule.exports = Subsegment;","map":{"version":3,"names":["crypto","require","CapturedException","RemoteRequestData","SegmentEmitter","SegmentUtils","Utils","logger","Subsegment","name","init","prototype","Error","id","randomBytes","toString","start_time","getCurrentTime","in_progress","counter","notTraced","addNewSubsegment","subsegment","addSubsegment","addSubsegmentWithoutSampling","addNewSubsegmentWithoutSampling","subsegments","undefined","segment","parent","noOp","end_time","incrementCounter","push","removeSubsegment","index","indexOf","splice","addAttribute","data","addPrecursorId","getLogger","error","precursor_ids","addAnnotation","key","value","isFinite","annotations","addMetadata","namespace","ns","metadata","addSqlData","sqlData","sql","addError","err","remote","addFaultFlag","exception","ex","fault","cause","exceptions","working_directory","process","cwd","unshift","addRemoteRequestData","req","res","downstreamXRayEnabled","http","request","traced","addErrorFlag","addThrottleFlag","throttle","close","root","decrementCounter","getStreamingThreshold","streamSubsegments","additional","isClosed","flush","trace_id","send","debug","length","open","forEach","child","format","type","parent_id","serialize","toJSON","ignore","thisCopy","objectWithoutProperties","object","JSON","stringify","getJsonStringifyReplacer","module","exports"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/segments/attributes/subsegment.js"],"sourcesContent":["\"use strict\";\nvar crypto = require('crypto');\nvar CapturedException = require('./captured_exception');\nvar RemoteRequestData = require('./remote_request_data');\nvar SegmentEmitter = require('../../segment_emitter');\nvar SegmentUtils = require('../segment_utils');\nvar Utils = require('../../utils');\nvar logger = require('../../logger');\n/**\n * Represents a subsegment.\n * @constructor\n * @param {string} name - The name of the subsegment.\n */\nfunction Subsegment(name) {\n    this.init(name);\n}\nSubsegment.prototype.init = function init(name) {\n    if (typeof name != 'string') {\n        throw new Error('Subsegment name must be of type string.');\n    }\n    this.id = crypto.randomBytes(8).toString('hex');\n    this.name = name;\n    this.start_time = SegmentUtils.getCurrentTime();\n    this.in_progress = true;\n    this.counter = 0;\n    this.notTraced = false;\n};\n/**\n * Nests a new subsegment to the array of subsegments.\n * @param {string} name - The name of the new subsegment to append.\n * @returns {Subsegment} - The newly created subsegment.\n */\nSubsegment.prototype.addNewSubsegment = function addNewSubsegment(name) {\n    const subsegment = new Subsegment(name);\n    this.addSubsegment(subsegment);\n    return subsegment;\n};\nSubsegment.prototype.addSubsegmentWithoutSampling = function addSubsegmentWithoutSampling(subsegment) {\n    this.addSubsegment(subsegment);\n    subsegment.notTraced = true;\n};\nSubsegment.prototype.addNewSubsegmentWithoutSampling = function addNewSubsegmentWithoutSampling(name) {\n    const subsegment = new Subsegment(name);\n    this.addSubsegment(subsegment);\n    subsegment.notTraced = true;\n    return subsegment;\n};\n/**\n * Adds a subsegment to the array of subsegments.\n * @param {Subsegment} subsegment - The subsegment to append.\n */\nSubsegment.prototype.addSubsegment = function (subsegment) {\n    if (!(subsegment instanceof Subsegment)) {\n        throw new Error('Failed to add subsegment:' + subsegment + ' to subsegment \"' + this.name +\n            '\".  Not a subsegment.');\n    }\n    if (this.subsegments === undefined) {\n        this.subsegments = [];\n    }\n    subsegment.segment = this.segment;\n    subsegment.parent = this;\n    subsegment.notTraced = subsegment.parent.notTraced;\n    subsegment.noOp = subsegment.parent.noOp;\n    if (subsegment.end_time === undefined) {\n        this.incrementCounter(subsegment.counter);\n    }\n    this.subsegments.push(subsegment);\n};\n/**\n * Removes the subsegment from the subsegments array, used in subsegment streaming.\n */\nSubsegment.prototype.removeSubsegment = function removeSubsegment(subsegment) {\n    if (!(subsegment instanceof Subsegment)) {\n        throw new Error('Failed to remove subsegment:' + subsegment + ' from subsegment \"' + this.name +\n            '\".  Not a subsegment.');\n    }\n    if (this.subsegments !== undefined) {\n        var index = this.subsegments.indexOf(subsegment);\n        if (index >= 0) {\n            this.subsegments.splice(index, 1);\n        }\n    }\n};\n/**\n * Adds a property with associated data into the subsegment.\n * @param {string} name - The name of the property to add.\n * @param {Object} data - The data of the property to add.\n */\nSubsegment.prototype.addAttribute = function addAttribute(name, data) {\n    this[name] = data;\n};\n/**\n * Adds a subsegement id to record ordering.\n * @param {string} id - A subsegment id.\n */\nSubsegment.prototype.addPrecursorId = function (id) {\n    if (typeof id !== 'string') {\n        logger.getLogger().error('Failed to add id:' + id + ' to subsegment ' + this.name +\n            '.  Precursor Ids must be of type string.');\n    }\n    if (this.precursor_ids === undefined) {\n        this.precursor_ids = [];\n    }\n    this.precursor_ids.push(id);\n};\n/**\n * Adds a key-value pair that can be queryable through GetTraceSummaries.\n * Only acceptable types are string, float/int and boolean.\n * @param {string} key - The name of key to add.\n * @param {boolean|string|number} value - The value to add for the given key.\n */\nSubsegment.prototype.addAnnotation = function (key, value) {\n    if (typeof value !== 'boolean' && typeof value !== 'string' && !isFinite(value)) {\n        logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Value must be of type string, number or boolean.');\n        return;\n    }\n    if (typeof key !== 'string') {\n        logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Key must be of type string.');\n        return;\n    }\n    if (this.annotations === undefined) {\n        this.annotations = {};\n    }\n    this.annotations[key] = value;\n};\n/**\n * Adds a key-value pair to the metadata.default attribute when no namespace is given.\n * Metadata is not queryable, but is recorded.\n * @param {string} key - The name of the key to add.\n * @param {object|null} value - The value of the associated key.\n * @param {string} [namespace] - The property name to put the key/value pair under.\n */\nSubsegment.prototype.addMetadata = function (key, value, namespace) {\n    if (typeof key !== 'string') {\n        logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Key must be of type string.');\n        return;\n    }\n    if (namespace && typeof namespace !== 'string') {\n        logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Namespace must be of type string.');\n        return;\n    }\n    var ns = namespace || 'default';\n    if (!this.metadata) {\n        this.metadata = {};\n    }\n    if (!this.metadata[ns]) {\n        this.metadata[ns] = {};\n    }\n    if (ns !== '__proto__') {\n        this.metadata[ns][key] = value !== null && value !== undefined ? value : '';\n    }\n};\nSubsegment.prototype.addSqlData = function addSqlData(sqlData) {\n    this.sql = sqlData;\n};\n/**\n * Adds an error with associated data into the subsegment.\n * To handle propagating errors, the subsegment also sets a copy of the error on the\n * root segment.  As the error passes up the execution stack, a reference is created\n * on each subsegment to the originating subsegment.\n * @param {Error|string} err - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSubsegment.prototype.addError = function addError(err, remote) {\n    if (err == null || typeof err !== 'object' && typeof (err) !== 'string') {\n        logger.getLogger().error('Failed to add error:' + err + ' to subsegment \"' + this.name +\n            '\".  Not an object or string literal.');\n        return;\n    }\n    this.addFaultFlag();\n    if (this.segment && this.segment.exception) {\n        if (err === this.segment.exception.ex) {\n            this.fault = true;\n            this.cause = { id: this.segment.exception.cause, exceptions: [] };\n            return;\n        }\n        delete this.segment.exception;\n    }\n    if (this.segment) {\n        this.segment.exception = {\n            ex: err,\n            cause: this.id\n        };\n    }\n    else {\n        //error, cannot propagate exception if not added to segment\n    }\n    if (this.cause === undefined) {\n        this.cause = {\n            working_directory: process.cwd(),\n            exceptions: []\n        };\n    }\n    this.cause.exceptions.unshift(new CapturedException(err, remote));\n};\n/**\n * Adds data for an outgoing HTTP/HTTPS call.\n * @param {http.ClientRequest/https.ClientRequest} req - The request object from the HTTP/HTTPS call.\n * @param {http.IncomingMessage/https.IncomingMessage} res - The response object from the HTTP/HTTPS call.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced\": true hint to generated subsegments such that the AWS X-Ray service expects a corresponding segment from the downstream service.\n */\nSubsegment.prototype.addRemoteRequestData = function addRemoteRequestData(req, res, downstreamXRayEnabled) {\n    this.http = new RemoteRequestData(req, res, downstreamXRayEnabled);\n    if ('traced' in this.http.request) {\n        this.traced = this.http.request.traced;\n        delete this.http.request.traced;\n    }\n};\n/**\n * Adds fault flag to the subsegment.\n */\nSubsegment.prototype.addFaultFlag = function addFaultFlag() {\n    this.fault = true;\n};\n/**\n * Adds error flag to the subsegment.\n */\nSubsegment.prototype.addErrorFlag = function addErrorFlag() {\n    this.error = true;\n};\n/**\n * Adds throttle flag to the subsegment.\n */\nSubsegment.prototype.addThrottleFlag = function addThrottleFlag() {\n    this.throttle = true;\n};\n/**\n * Closes the current subsegment.  This automatically captures any exceptions and sets the end time.\n * @param {Error|string} [err] - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSubsegment.prototype.close = function close(err, remote) {\n    var root = this.segment;\n    this.end_time = SegmentUtils.getCurrentTime();\n    delete this.in_progress;\n    if (err) {\n        this.addError(err, remote);\n    }\n    if (this.parent) {\n        this.parent.decrementCounter();\n    }\n    if (root && root.counter > SegmentUtils.getStreamingThreshold()) {\n        if (this.streamSubsegments() && this.parent) {\n            this.parent.removeSubsegment(this);\n        }\n    }\n};\n/**\n * Each subsegment holds a counter of open subsegments.  This increments\n * the counter such that it can be called from a child and propagate up.\n * @param {Number} [additional] - An additional amount to increment.  Used when adding subsegment trees.\n */\nSubsegment.prototype.incrementCounter = function incrementCounter(additional) {\n    this.counter = additional ? this.counter + additional + 1 : this.counter + 1;\n    if (this.parent) {\n        this.parent.incrementCounter(additional);\n    }\n};\n/**\n * Each subsegment holds a counter of its open subsegments.  This decrements\n * the counter such that it can be called from a child and propagate up.\n */\nSubsegment.prototype.decrementCounter = function decrementCounter() {\n    this.counter--;\n    if (this.parent) {\n        this.parent.decrementCounter();\n    }\n};\n/**\n * Returns a boolean indicating whether or not the subsegment has been closed.\n * @returns {boolean} - Returns true if the subsegment is closed.\n */\nSubsegment.prototype.isClosed = function isClosed() {\n    return !this.in_progress;\n};\n/**\n * Sends the subsegment to the daemon.\n */\nSubsegment.prototype.flush = function flush() {\n    if (!this.parent || !this.segment) {\n        logger.getLogger().error('Failed to flush subsegment: ' + this.name + '. Subsegment must be added ' +\n            'to a segment chain to flush.');\n        return;\n    }\n    if (this.segment.trace_id) {\n        if (this.segment.notTraced !== true && !this.notTraced) {\n            SegmentEmitter.send(this);\n        }\n        else {\n            logger.getLogger().debug('Ignoring flush on subsegment ' + this.id + '. Associated segment is marked as not sampled.');\n        }\n    }\n    else {\n        logger.getLogger().debug('Ignoring flush on subsegment ' + this.id + '. Associated segment is missing a trace ID.');\n    }\n};\n/**\n * Returns true if the subsegment was streamed in its entirety\n */\nSubsegment.prototype.streamSubsegments = function streamSubsegments() {\n    if (this.isClosed() && this.counter <= 0) {\n        this.flush();\n        return true;\n    }\n    else if (this.subsegments && this.subsegments.length > 0) {\n        var open = [];\n        this.subsegments.forEach(function (child) {\n            if (!child.streamSubsegments()) {\n                open.push(child);\n            }\n        });\n        this.subsegments = open;\n    }\n};\n/**\n * Returns the formatted, trimmed subsegment JSON string to send to the daemon.\n */\nSubsegment.prototype.format = function format() {\n    this.type = 'subsegment';\n    if (this.parent) {\n        this.parent_id = this.parent.id;\n    }\n    if (this.segment) {\n        this.trace_id = this.segment.trace_id;\n    }\n    return this.serialize();\n};\n/**\n * Returns the formatted subsegment JSON string.\n */\nSubsegment.prototype.toString = function toString() {\n    return this.serialize();\n};\nSubsegment.prototype.toJSON = function toJSON() {\n    var ignore = ['segment', 'parent', 'counter'];\n    if (this.subsegments == null || this.subsegments.length === 0) {\n        ignore.push('subsegments');\n    }\n    var thisCopy = Utils.objectWithoutProperties(this, ignore, false);\n    return thisCopy;\n};\n/**\n * Returns the serialized subsegment JSON string, replacing any BigInts with strings.\n */\nSubsegment.prototype.serialize = function serialize(object) {\n    return JSON.stringify(object !== null && object !== void 0 ? object : this, SegmentUtils.getJsonStringifyReplacer());\n};\nmodule.exports = Subsegment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}