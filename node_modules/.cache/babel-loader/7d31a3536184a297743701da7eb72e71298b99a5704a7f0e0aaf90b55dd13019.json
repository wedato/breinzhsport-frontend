{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar isInteger = require('math-intrinsics/isInteger');\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\nvar IsBigIntElementType = require('./IsBigIntElementType');\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar NumericToRawBytes = require('./NumericToRawBytes');\nvar isArrayBuffer = require('is-array-buffer');\nvar isSharedArrayBuffer = require('is-shared-array-buffer');\nvar hasOwn = require('hasown');\nvar tableTAO = require('./tables/typed-array-objects');\nvar defaultEndianness = require('../helpers/defaultEndianness');\nvar forEach = require('../helpers/forEach');\n\n// https://262.ecma-international.org/15.0/#sec-setvalueinbuffer\n\n/* eslint max-params: 0 */\n\nmodule.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {\n  var isSAB = isSharedArrayBuffer(arrayBuffer);\n  if (!isArrayBuffer(arrayBuffer) && !isSAB) {\n    throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');\n  }\n  if (!isInteger(byteIndex) || byteIndex < 0) {\n    throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');\n  }\n  if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {\n    throw new $TypeError('Assertion failed: `type` must be a Typed Array Element Type');\n  }\n  if (typeof value !== 'number' && typeof value !== 'bigint') {\n    throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');\n  }\n  if (typeof isTypedArray !== 'boolean') {\n    throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');\n  }\n  if (order !== 'SEQ-CST' && order !== 'UNORDERED' && order !== 'INIT') {\n    throw new $TypeError('Assertion failed: `order` must be `\"SEQ-CST\"`, `\"UNORDERED\"`, or `\"INIT\"`');\n  }\n  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n    throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');\n  }\n  if (IsDetachedBuffer(arrayBuffer)) {\n    throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1\n  }\n\n  // 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.\n\n  if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') {\n    // step 3\n    throw new $TypeError('Assertion failed: `value` must be a BigInt if type is ~BIGINT64~ or ~BIGUINT64~, otherwise a Number');\n  }\n\n  // 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.\n\n  var elementSize = tableTAO.size['$' + type]; // step 5\n\n  // 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.\n  var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6\n\n  var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7\n\n  if (isSAB) {\n    // step 8\n    /*\n    \tLet execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n    \tLet eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n    \tIf isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.\n    \tAppend WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.\n    */\n    throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');\n  } else {\n    // 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].\n    var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);\n    forEach(rawBytes, function (rawByte, i) {\n      arr[i] = rawByte;\n    });\n  }\n\n  // 10. Return NormalCompletion(undefined).\n};","map":{"version":3,"names":["GetIntrinsic","require","$SyntaxError","$TypeError","isInteger","$Uint8Array","IsBigIntElementType","IsDetachedBuffer","NumericToRawBytes","isArrayBuffer","isSharedArrayBuffer","hasOwn","tableTAO","defaultEndianness","forEach","module","exports","SetValueInBuffer","arrayBuffer","byteIndex","type","value","isTypedArray","order","isSAB","size","arguments","length","elementSize","isLittleEndian","rawBytes","arr","rawByte","i"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/es-abstract/2024/SetValueInBuffer.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar isInteger = require('math-intrinsics/isInteger');\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar IsBigIntElementType = require('./IsBigIntElementType');\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar NumericToRawBytes = require('./NumericToRawBytes');\n\nvar isArrayBuffer = require('is-array-buffer');\nvar isSharedArrayBuffer = require('is-shared-array-buffer');\nvar hasOwn = require('hasown');\n\nvar tableTAO = require('./tables/typed-array-objects');\n\nvar defaultEndianness = require('../helpers/defaultEndianness');\nvar forEach = require('../helpers/forEach');\n\n// https://262.ecma-international.org/15.0/#sec-setvalueinbuffer\n\n/* eslint max-params: 0 */\n\nmodule.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {\n\tvar isSAB = isSharedArrayBuffer(arrayBuffer);\n\tif (!isArrayBuffer(arrayBuffer) && !isSAB) {\n\t\tthrow new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');\n\t}\n\n\tif (!isInteger(byteIndex) || byteIndex < 0) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');\n\t}\n\n\tif (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be a Typed Array Element Type');\n\t}\n\n\tif (typeof value !== 'number' && typeof value !== 'bigint') {\n\t\tthrow new $TypeError('Assertion failed: `value` must be a Number or a BigInt');\n\t}\n\n\tif (typeof isTypedArray !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isTypedArray` must be a boolean');\n\t}\n\tif (order !== 'SEQ-CST' && order !== 'UNORDERED' && order !== 'INIT') {\n\t\tthrow new $TypeError('Assertion failed: `order` must be `\"SEQ-CST\"`, `\"UNORDERED\"`, or `\"INIT\"`');\n\t}\n\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');\n\t}\n\n\tif (IsDetachedBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1\n\t}\n\n\t// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.\n\n\tif (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3\n\t\tthrow new $TypeError('Assertion failed: `value` must be a BigInt if type is ~BIGINT64~ or ~BIGUINT64~, otherwise a Number');\n\t}\n\n\t// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.\n\n\tvar elementSize = tableTAO.size['$' + type]; // step 5\n\n\t// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.\n\tvar isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6\n\n\tvar rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7\n\n\tif (isSAB) { // step 8\n\t\t/*\n\t\t\tLet execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n\t\t\tLet eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n\t\t\tIf isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.\n\t\t\tAppend WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.\n\t\t*/\n\t\tthrow new $SyntaxError('SharedArrayBuffer is not supported by this implementation');\n\t} else {\n\t\t// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].\n\t\tvar arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);\n\t\tforEach(rawBytes, function (rawByte, i) {\n\t\t\tarr[i] = rawByte;\n\t\t});\n\t}\n\n\t// 10. Return NormalCompletion(undefined).\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}