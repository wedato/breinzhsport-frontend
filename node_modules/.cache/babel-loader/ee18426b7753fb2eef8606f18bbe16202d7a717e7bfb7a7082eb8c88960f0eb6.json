{"ast":null,"code":"\"use strict\";\n\n/**\n * @module http_p\n */\n/**\n * This module patches the HTTP and HTTPS node built-in libraries and returns a copy of the module with tracing enabled.\n */\nvar url = require('url');\nvar contextUtils = require('../context_utils');\nvar Utils = require('../utils');\nvar logger = require('../logger');\nvar events = require('events');\n/**\n * Wraps the http/https.request() and .get() calls to automatically capture information for the segment.\n * This patches the built-in HTTP and HTTPS modules globally. If using a 3rd party HTTP library,\n * it should still use HTTP under the hood. Be sure to patch globally before requiring the 3rd party library.\n * 3rd party library compatibility is best effort. Some incompatibility issues may arise.\n * @param {http|https} module - The built in Node.js HTTP or HTTPS module.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced:true\" property to the subsegment\n *   so the AWS X-Ray service expects a corresponding segment from the downstream service.\n * @param {function} subsegmentCallback - a callback that is called with the subsegment, the Node.js\n *   http.ClientRequest, the Node.js http.IncomingMessage (if a response was received) and any error issued,\n *   allowing custom annotations and metadata to be added.\n *   to be added to the subsegment.\n * @alias module:http_p.captureHTTPsGlobal\n */\nvar captureHTTPsGlobal = function captureHTTPsGlobal(module, downstreamXRayEnabled, subsegmentCallback) {\n  if (!module.__request) {\n    enableCapture(module, downstreamXRayEnabled, subsegmentCallback);\n  }\n};\n/**\n * Wraps the http/https.request() and .get() calls to automatically capture information for the segment.\n * Returns an instance of the HTTP or HTTPS module that is patched.\n * @param {http|https} module - The built in Node.js HTTP or HTTPS module.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced:true\" property to the subsegment\n *   so the AWS X-Ray service expects a corresponding segment from the downstream service.\n * @param {function} subsegmentCallback - a callback that is called with the subsegment, the Node.js\n *   http.ClientRequest, and the Node.js http.IncomingMessage to allow custom annotations and metadata\n *   to be added to the subsegment.\n * @alias module:http_p.captureHTTPs\n * @returns {http|https}\n */\nvar captureHTTPs = function captureHTTPs(module, downstreamXRayEnabled, subsegmentCallback) {\n  if (module.__request) {\n    return module;\n  }\n  var tracedModule = {};\n  Object.keys(module).forEach(function (val) {\n    tracedModule[val] = module[val];\n  });\n  enableCapture(tracedModule, downstreamXRayEnabled, subsegmentCallback);\n  return tracedModule;\n};\nfunction enableCapture(module, downstreamXRayEnabled, subsegmentCallback) {\n  function captureOutgoingHTTPs(baseFunc) {\n    let options;\n    let callback;\n    let hasUrl;\n    let urlObj;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let arg0 = args[0];\n    if (typeof args[1] === 'object') {\n      hasUrl = true;\n      urlObj = typeof arg0 === 'string' ? new url.URL(arg0) : arg0;\n      options = args[1], callback = args[2];\n    } else {\n      hasUrl = false;\n      options = arg0;\n      callback = args[1];\n    }\n    // Short circuit if the HTTP request has no options or is already being captured\n    if (!options || options.headers && options.headers['X-Amzn-Trace-Id']) {\n      return baseFunc(...args);\n    }\n    // Case of calling a string URL without options, e.g.: http.request('http://amazon.com', callback)\n    if (typeof options === 'string') {\n      options = new url.URL(options);\n    }\n    if (!hasUrl) {\n      urlObj = options;\n    }\n    const parent = contextUtils.resolveSegment(contextUtils.resolveManualSegmentParams(options));\n    const hostname = options.hostname || options.host || urlObj.hostname || urlObj.host || 'Unknown host';\n    if (!parent) {\n      let output = '[ host: ' + hostname;\n      output = options.method ? output + ', method: ' + options.method : output;\n      output += ', path: ' + (urlObj.pathname || Utils.stripQueryStringFromPath(options.path)) + ' ]';\n      if (!contextUtils.isAutomaticMode()) {\n        logger.getLogger().info('Options for request ' + output + ' requires a segment object on the options params as \"XRaySegment\" for tracing in manual mode. Ignoring.');\n      } else {\n        logger.getLogger().info('Options for request ' + output + ' is missing the sub/segment context for automatic mode. Ignoring.');\n      }\n      // Options are not modified, only parsed for logging. We can pass in the original arguments.\n      return baseFunc(...args);\n    }\n    let subsegment;\n    if (parent.notTraced) {\n      subsegment = parent.addNewSubsegmentWithoutSampling(hostname);\n    } else {\n      subsegment = parent.addNewSubsegment(hostname);\n    }\n    const root = parent.segment ? parent.segment : parent;\n    subsegment.namespace = 'remote';\n    if (!options.headers) {\n      options.headers = {};\n    }\n    if (!parent.noOp) {\n      options.headers['X-Amzn-Trace-Id'] = 'Root=' + root.trace_id + ';Parent=' + subsegment.id + ';Sampled=' + (subsegment.notTraced ? '0' : '1');\n    }\n    const errorCapturer = function errorCapturer(e) {\n      if (subsegmentCallback) {\n        subsegmentCallback(subsegment, this, null, e);\n      }\n      if (subsegment.http && subsegment.http.response) {\n        if (Utils.getCauseTypeFromHttpStatus(subsegment.http.response.status) === 'error') {\n          subsegment.addErrorFlag();\n        }\n        subsegment.close(e, true);\n      } else {\n        const madeItToDownstream = e.code !== 'ECONNREFUSED';\n        subsegment.addRemoteRequestData(this, null, madeItToDownstream && downstreamXRayEnabled);\n        subsegment.close(e);\n      }\n    };\n    const optionsCopy = Utils.objectWithoutProperties(options, ['Segment'], true);\n    let req = baseFunc(...(hasUrl ? [arg0, optionsCopy] : [options]), function (res) {\n      res.on('end', function () {\n        if (subsegmentCallback) {\n          subsegmentCallback(subsegment, this.req, res);\n        }\n        if (res.statusCode === 429) {\n          subsegment.addThrottleFlag();\n        }\n        const cause = Utils.getCauseTypeFromHttpStatus(res.statusCode);\n        if (cause) {\n          subsegment[cause] = true;\n        }\n        subsegment.addRemoteRequestData(res.req, res, !!downstreamXRayEnabled);\n        subsegment.close();\n      });\n      if (typeof callback === 'function') {\n        if (contextUtils.isAutomaticMode()) {\n          const session = contextUtils.getNamespace();\n          session.run(function () {\n            contextUtils.setSegment(subsegment);\n            callback(res);\n          });\n        } else {\n          callback(res);\n        }\n        // if no callback provided by user application, AND no explicit response listener\n        // added by user application, then we consume the response so the 'end' event fires\n        // See: https://nodejs.org/api/http.html#http_class_http_clientrequest\n      } else if (res.req && res.req.listenerCount('response') === 0) {\n        res.resume();\n      }\n    });\n    // Use errorMonitor if available (in Node 12.17+), otherwise fall back to standard error listener\n    // See: https://nodejs.org/dist/latest-v12.x/docs/api/events.html#events_eventemitter_errormonitor\n    req.on(events.errorMonitor || 'error', errorCapturer);\n    return req;\n  }\n  module.__request = module.request;\n  function captureHTTPsRequest() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return captureOutgoingHTTPs(module.__request, ...args);\n  }\n  module.__get = module.get;\n  function captureHTTPsGet() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return captureOutgoingHTTPs(module.__get, ...args);\n  }\n  Object.defineProperties(module, {\n    request: {\n      value: captureHTTPsRequest,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    },\n    get: {\n      value: captureHTTPsGet,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }\n  });\n}\nmodule.exports.captureHTTPsGlobal = captureHTTPsGlobal;\nmodule.exports.captureHTTPs = captureHTTPs;","map":{"version":3,"names":["url","require","contextUtils","Utils","logger","events","captureHTTPsGlobal","module","downstreamXRayEnabled","subsegmentCallback","__request","enableCapture","captureHTTPs","tracedModule","Object","keys","forEach","val","captureOutgoingHTTPs","baseFunc","options","callback","hasUrl","urlObj","_len","arguments","length","args","Array","_key","arg0","URL","headers","parent","resolveSegment","resolveManualSegmentParams","hostname","host","output","method","pathname","stripQueryStringFromPath","path","isAutomaticMode","getLogger","info","subsegment","notTraced","addNewSubsegmentWithoutSampling","addNewSubsegment","root","segment","namespace","noOp","trace_id","id","errorCapturer","e","http","response","getCauseTypeFromHttpStatus","status","addErrorFlag","close","madeItToDownstream","code","addRemoteRequestData","optionsCopy","objectWithoutProperties","req","res","on","statusCode","addThrottleFlag","cause","session","getNamespace","run","setSegment","listenerCount","resume","errorMonitor","request","captureHTTPsRequest","_len2","_key2","__get","get","captureHTTPsGet","_len3","_key3","defineProperties","value","configurable","enumerable","writable","exports"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/patchers/http_p.js"],"sourcesContent":["\"use strict\";\n/**\n * @module http_p\n */\n/**\n * This module patches the HTTP and HTTPS node built-in libraries and returns a copy of the module with tracing enabled.\n */\nvar url = require('url');\nvar contextUtils = require('../context_utils');\nvar Utils = require('../utils');\nvar logger = require('../logger');\nvar events = require('events');\n/**\n * Wraps the http/https.request() and .get() calls to automatically capture information for the segment.\n * This patches the built-in HTTP and HTTPS modules globally. If using a 3rd party HTTP library,\n * it should still use HTTP under the hood. Be sure to patch globally before requiring the 3rd party library.\n * 3rd party library compatibility is best effort. Some incompatibility issues may arise.\n * @param {http|https} module - The built in Node.js HTTP or HTTPS module.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced:true\" property to the subsegment\n *   so the AWS X-Ray service expects a corresponding segment from the downstream service.\n * @param {function} subsegmentCallback - a callback that is called with the subsegment, the Node.js\n *   http.ClientRequest, the Node.js http.IncomingMessage (if a response was received) and any error issued,\n *   allowing custom annotations and metadata to be added.\n *   to be added to the subsegment.\n * @alias module:http_p.captureHTTPsGlobal\n */\nvar captureHTTPsGlobal = function captureHTTPsGlobal(module, downstreamXRayEnabled, subsegmentCallback) {\n    if (!module.__request) {\n        enableCapture(module, downstreamXRayEnabled, subsegmentCallback);\n    }\n};\n/**\n * Wraps the http/https.request() and .get() calls to automatically capture information for the segment.\n * Returns an instance of the HTTP or HTTPS module that is patched.\n * @param {http|https} module - The built in Node.js HTTP or HTTPS module.\n * @param {boolean} downstreamXRayEnabled - when true, adds a \"traced:true\" property to the subsegment\n *   so the AWS X-Ray service expects a corresponding segment from the downstream service.\n * @param {function} subsegmentCallback - a callback that is called with the subsegment, the Node.js\n *   http.ClientRequest, and the Node.js http.IncomingMessage to allow custom annotations and metadata\n *   to be added to the subsegment.\n * @alias module:http_p.captureHTTPs\n * @returns {http|https}\n */\nvar captureHTTPs = function captureHTTPs(module, downstreamXRayEnabled, subsegmentCallback) {\n    if (module.__request) {\n        return module;\n    }\n    var tracedModule = {};\n    Object.keys(module).forEach(function (val) {\n        tracedModule[val] = module[val];\n    });\n    enableCapture(tracedModule, downstreamXRayEnabled, subsegmentCallback);\n    return tracedModule;\n};\nfunction enableCapture(module, downstreamXRayEnabled, subsegmentCallback) {\n    function captureOutgoingHTTPs(baseFunc, ...args) {\n        let options;\n        let callback;\n        let hasUrl;\n        let urlObj;\n        let arg0 = args[0];\n        if (typeof args[1] === 'object') {\n            hasUrl = true;\n            urlObj = typeof arg0 === 'string' ? new url.URL(arg0) : arg0;\n            options = args[1],\n                callback = args[2];\n        }\n        else {\n            hasUrl = false;\n            options = arg0;\n            callback = args[1];\n        }\n        // Short circuit if the HTTP request has no options or is already being captured\n        if (!options || (options.headers && (options.headers['X-Amzn-Trace-Id']))) {\n            return baseFunc(...args);\n        }\n        // Case of calling a string URL without options, e.g.: http.request('http://amazon.com', callback)\n        if (typeof options === 'string') {\n            options = new url.URL(options);\n        }\n        if (!hasUrl) {\n            urlObj = options;\n        }\n        const parent = contextUtils.resolveSegment(contextUtils.resolveManualSegmentParams(options));\n        const hostname = options.hostname || options.host || urlObj.hostname || urlObj.host || 'Unknown host';\n        if (!parent) {\n            let output = '[ host: ' + hostname;\n            output = options.method ? (output + ', method: ' + options.method) : output;\n            output += ', path: ' + (urlObj.pathname || Utils.stripQueryStringFromPath(options.path)) + ' ]';\n            if (!contextUtils.isAutomaticMode()) {\n                logger.getLogger().info('Options for request ' + output +\n                    ' requires a segment object on the options params as \"XRaySegment\" for tracing in manual mode. Ignoring.');\n            }\n            else {\n                logger.getLogger().info('Options for request ' + output +\n                    ' is missing the sub/segment context for automatic mode. Ignoring.');\n            }\n            // Options are not modified, only parsed for logging. We can pass in the original arguments.\n            return baseFunc(...args);\n        }\n        let subsegment;\n        if (parent.notTraced) {\n            subsegment = parent.addNewSubsegmentWithoutSampling(hostname);\n        }\n        else {\n            subsegment = parent.addNewSubsegment(hostname);\n        }\n        const root = parent.segment ? parent.segment : parent;\n        subsegment.namespace = 'remote';\n        if (!options.headers) {\n            options.headers = {};\n        }\n        if (!parent.noOp) {\n            options.headers['X-Amzn-Trace-Id'] = 'Root=' + root.trace_id + ';Parent=' + subsegment.id +\n                ';Sampled=' + (subsegment.notTraced ? '0' : '1');\n        }\n        const errorCapturer = function errorCapturer(e) {\n            if (subsegmentCallback) {\n                subsegmentCallback(subsegment, this, null, e);\n            }\n            if (subsegment.http && subsegment.http.response) {\n                if (Utils.getCauseTypeFromHttpStatus(subsegment.http.response.status) === 'error') {\n                    subsegment.addErrorFlag();\n                }\n                subsegment.close(e, true);\n            }\n            else {\n                const madeItToDownstream = (e.code !== 'ECONNREFUSED');\n                subsegment.addRemoteRequestData(this, null, madeItToDownstream && downstreamXRayEnabled);\n                subsegment.close(e);\n            }\n        };\n        const optionsCopy = Utils.objectWithoutProperties(options, ['Segment'], true);\n        let req = baseFunc(...(hasUrl ? [arg0, optionsCopy] : [options]), function (res) {\n            res.on('end', function () {\n                if (subsegmentCallback) {\n                    subsegmentCallback(subsegment, this.req, res);\n                }\n                if (res.statusCode === 429) {\n                    subsegment.addThrottleFlag();\n                }\n                const cause = Utils.getCauseTypeFromHttpStatus(res.statusCode);\n                if (cause) {\n                    subsegment[cause] = true;\n                }\n                subsegment.addRemoteRequestData(res.req, res, !!downstreamXRayEnabled);\n                subsegment.close();\n            });\n            if (typeof callback === 'function') {\n                if (contextUtils.isAutomaticMode()) {\n                    const session = contextUtils.getNamespace();\n                    session.run(function () {\n                        contextUtils.setSegment(subsegment);\n                        callback(res);\n                    });\n                }\n                else {\n                    callback(res);\n                }\n                // if no callback provided by user application, AND no explicit response listener\n                // added by user application, then we consume the response so the 'end' event fires\n                // See: https://nodejs.org/api/http.html#http_class_http_clientrequest\n            }\n            else if (res.req && res.req.listenerCount('response') === 0) {\n                res.resume();\n            }\n        });\n        // Use errorMonitor if available (in Node 12.17+), otherwise fall back to standard error listener\n        // See: https://nodejs.org/dist/latest-v12.x/docs/api/events.html#events_eventemitter_errormonitor\n        req.on(events.errorMonitor || 'error', errorCapturer);\n        return req;\n    }\n    module.__request = module.request;\n    function captureHTTPsRequest(...args) {\n        return captureOutgoingHTTPs(module.__request, ...args);\n    }\n    module.__get = module.get;\n    function captureHTTPsGet(...args) {\n        return captureOutgoingHTTPs(module.__get, ...args);\n    }\n    Object.defineProperties(module, {\n        request: { value: captureHTTPsRequest, configurable: true, enumerable: true, writable: true },\n        get: { value: captureHTTPsGet, configurable: true, enumerable: true, writable: true },\n    });\n}\nmodule.exports.captureHTTPsGlobal = captureHTTPsGlobal;\nmodule.exports.captureHTTPs = captureHTTPs;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}