{"ast":null,"code":"'use strict';\n\nvar $TypeError = require('es-errors/type');\nvar Get = require('es-abstract/2024/Get');\nvar GetValueFromBuffer = require('es-abstract/2024/GetValueFromBuffer');\nvar IsDetachedBuffer = require('es-abstract/2024/IsDetachedBuffer');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar Set = require('es-abstract/2024/Set');\nvar SetValueInBuffer = require('es-abstract/2024/SetValueInBuffer');\nvar ToIntegerOrInfinity = require('es-abstract/2024/ToIntegerOrInfinity');\nvar ToString = require('es-abstract/2024/ToString');\nvar TypedArrayElementSize = require('es-abstract/2024/TypedArrayElementSize');\nvar TypedArrayElementType = require('es-abstract/2024/TypedArrayElementType');\nvar TypedArraySpeciesCreate = require('es-abstract/2024/TypedArraySpeciesCreate');\nvar ValidateTypedArray = require('es-abstract/2024/ValidateTypedArray');\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\n\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice\n\nmodule.exports = function slice(start, end) {\n  var O = this; // step 1\n\n  ValidateTypedArray(O, 'SEQ-CST'); // step 2\n\n  // 3. Let len be O.[[ArrayLength]].\n  var len = O.length; // steps 3\n\n  var relativeStart = ToIntegerOrInfinity(start); // step 4\n\n  var k;\n  if (relativeStart === -Infinity) {\n    k = 0; // step 5\n  } else if (relativeStart < 0) {\n    k = max(len + relativeStart, 0); // step 6\n  } else {\n    k = min(relativeStart, len); // step 7\n  }\n  var relativeEnd = typeof end === 'undefined' ? len : ToIntegerOrInfinity(end); // step 8\n\n  var final;\n  if (relativeEnd === -Infinity) {\n    final = 0; // step 9\n  } else if (relativeEnd < 0) {\n    final = max(len + relativeEnd, 0); // step 10\n  } else {\n    final = min(relativeEnd, len); // step 11\n  }\n  var count = max(final - k, 0); // step 12\n\n  var A = TypedArraySpeciesCreate(O, [count]); // step 13\n\n  if (count > 0) {\n    // step 14\n    if (IsDetachedBuffer(typedArrayBuffer(O))) {\n      throw new $TypeError('Cannot use a Typed Array with an underlying ArrayBuffer that is detached'); // step 14.a\n    }\n    var srcType = TypedArrayElementType(O); // step 14.b\n    var targetType = TypedArrayElementType(A); // step 14.c\n    if (srcType === targetType) {\n      // step 14.d\n      //  1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n      var srcBuffer = typedArrayBuffer(O); // step 14.d.ii\n      var targetBuffer = typedArrayBuffer(A); // step 14.d.iii\n      var elementSize = TypedArrayElementSize(O); // step 14.d.iv\n      var srcByteOffset = typedArrayByteOffset(O); // step 14.d.v\n      var srcByteIndex = k * elementSize + srcByteOffset; // step 14.d.vi\n      var targetByteIndex = typedArrayByteOffset(A); // step 14.d.vii\n      var limit = targetByteIndex + count * elementSize; // step 14.d.viii\n      while (targetByteIndex < limit) {\n        // step 14.d.ix\n        var value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'UINT8', true, 'UNORDERED'); // step 14.d.ix.1\n        SetValueInBuffer(targetBuffer, targetByteIndex, 'UINT8', value, true, 'UNORDERED'); // step 14.d.ix.2\n        srcByteIndex += 1; // step 14.d.ix.3\n        targetByteIndex += 1; // step 14.d.ix.4\n      }\n    } else {\n      // step 14.e\n      var n = 0; // step 14.e.i\n      while (k < final) {\n        // step 14.e.ii\n        var Pk = ToString(k); // step 14.e.ii.1\n        var kValue = Get(O, Pk); // step 14.e.ii.2\n        Set(A, ToString(n), kValue, true); // step 14.e.ii.3\n        k += 1; // step 14.e.ii.4\n        n += 1; // step 14.e.ii.5\n      }\n    }\n  }\n  return A; // step 15\n};","map":{"version":3,"names":["$TypeError","require","Get","GetValueFromBuffer","IsDetachedBuffer","max","min","Set","SetValueInBuffer","ToIntegerOrInfinity","ToString","TypedArrayElementSize","TypedArrayElementType","TypedArraySpeciesCreate","ValidateTypedArray","typedArrayBuffer","typedArrayByteOffset","module","exports","slice","start","end","O","len","length","relativeStart","k","Infinity","relativeEnd","final","count","A","srcType","targetType","srcBuffer","targetBuffer","elementSize","srcByteOffset","srcByteIndex","targetByteIndex","limit","value","n","Pk","kValue"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/typedarray.prototype.slice/implementation.js"],"sourcesContent":["'use strict';\n\nvar $TypeError = require('es-errors/type');\n\nvar Get = require('es-abstract/2024/Get');\nvar GetValueFromBuffer = require('es-abstract/2024/GetValueFromBuffer');\nvar IsDetachedBuffer = require('es-abstract/2024/IsDetachedBuffer');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar Set = require('es-abstract/2024/Set');\nvar SetValueInBuffer = require('es-abstract/2024/SetValueInBuffer');\nvar ToIntegerOrInfinity = require('es-abstract/2024/ToIntegerOrInfinity');\nvar ToString = require('es-abstract/2024/ToString');\nvar TypedArrayElementSize = require('es-abstract/2024/TypedArrayElementSize');\nvar TypedArrayElementType = require('es-abstract/2024/TypedArrayElementType');\nvar TypedArraySpeciesCreate = require('es-abstract/2024/TypedArraySpeciesCreate');\nvar ValidateTypedArray = require('es-abstract/2024/ValidateTypedArray');\n\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\n\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice\n\nmodule.exports = function slice(start, end) {\n\tvar O = this; // step 1\n\n\tValidateTypedArray(O, 'SEQ-CST'); // step 2\n\n\t// 3. Let len be O.[[ArrayLength]].\n\tvar len = O.length; // steps 3\n\n\tvar relativeStart = ToIntegerOrInfinity(start); // step 4\n\n\tvar k;\n\tif (relativeStart === -Infinity) {\n\t\tk = 0; // step 5\n\t} else if (relativeStart < 0) {\n\t\tk = max(len + relativeStart, 0); // step 6\n\t} else {\n\t\tk = min(relativeStart, len); // step 7\n\t}\n\n\tvar relativeEnd = typeof end === 'undefined' ? len : ToIntegerOrInfinity(end); // step 8\n\n\tvar final;\n\tif (relativeEnd === -Infinity) {\n\t\tfinal = 0; // step 9\n\t} else if (relativeEnd < 0) {\n\t\tfinal = max(len + relativeEnd, 0); // step 10\n\t} else {\n\t\tfinal = min(relativeEnd, len); // step 11\n\t}\n\n\tvar count = max(final - k, 0); // step 12\n\n\tvar A = TypedArraySpeciesCreate(O, [count]); // step 13\n\n\tif (count > 0) { // step 14\n\t\tif (IsDetachedBuffer(typedArrayBuffer(O))) {\n\t\t\tthrow new $TypeError('Cannot use a Typed Array with an underlying ArrayBuffer that is detached'); // step 14.a\n\t\t}\n\t\tvar srcType = TypedArrayElementType(O); // step 14.b\n\t\tvar targetType = TypedArrayElementType(A); // step 14.c\n\t\tif (srcType === targetType) { // step 14.d\n\t\t\t//  1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\t\t\tvar srcBuffer = typedArrayBuffer(O); // step 14.d.ii\n\t\t\tvar targetBuffer = typedArrayBuffer(A); // step 14.d.iii\n\t\t\tvar elementSize = TypedArrayElementSize(O); // step 14.d.iv\n\t\t\tvar srcByteOffset = typedArrayByteOffset(O); // step 14.d.v\n\t\t\tvar srcByteIndex = (k * elementSize) + srcByteOffset; // step 14.d.vi\n\t\t\tvar targetByteIndex = typedArrayByteOffset(A); // step 14.d.vii\n\t\t\tvar limit = targetByteIndex + (count * elementSize); // step 14.d.viii\n\t\t\twhile (targetByteIndex < limit) { // step 14.d.ix\n\t\t\t\tvar value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'UINT8', true, 'UNORDERED'); // step 14.d.ix.1\n\t\t\t\tSetValueInBuffer(targetBuffer, targetByteIndex, 'UINT8', value, true, 'UNORDERED'); // step 14.d.ix.2\n\t\t\t\tsrcByteIndex += 1; // step 14.d.ix.3\n\t\t\t\ttargetByteIndex += 1; // step 14.d.ix.4\n\t\t\t}\n\t\t} else { // step 14.e\n\t\t\tvar n = 0; // step 14.e.i\n\t\t\twhile (k < final) { // step 14.e.ii\n\t\t\t\tvar Pk = ToString(k); // step 14.e.ii.1\n\t\t\t\tvar kValue = Get(O, Pk); // step 14.e.ii.2\n\t\t\t\tSet(A, ToString(n), kValue, true); // step 14.e.ii.3\n\t\t\t\tk += 1; // step 14.e.ii.4\n\t\t\t\tn += 1; // step 14.e.ii.5\n\t\t\t}\n\t\t}\n\t}\n\n\treturn A; // step 15\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}