{"ast":null,"code":"import * as Constants from './constants.js';\nexport default function render() {\n  // eslint-disable-next-line no-invalid-this\n  const store = this;\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n  const mode = store.ctx.events.currentModeName();\n  store.ctx.ui.queueMapClasses({\n    mode\n  });\n  let newHotIds = [];\n  let newColdIds = [];\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\n    newColdIds = store.sources.hot.filter(geojson => geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined).map(geojson => geojson.properties.id);\n  }\n  store.sources.hot = [];\n  const lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter(geojson => {\n    const id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\n  function renderFeature(id, source) {\n    const feature = store.get(id);\n    const featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, geojson => {\n      geojson.properties.mode = mode;\n      store.sources[source].push(geojson);\n    });\n  }\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n  cleanup();\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n}","map":{"version":3,"names":["Constants","render","store","mapExists","ctx","map","getSource","sources","HOT","undefined","cleanup","mode","events","currentModeName","ui","queueMapClasses","newHotIds","newColdIds","isDirty","getAllIds","getChangedIds","filter","id","get","hot","geojson","properties","indexOf","lastColdCount","cold","length","parent","coldChanged","forEach","renderFeature","source","feature","featureInternal","internal","currentModeRender","push","COLD","setData","type","geojsonTypes","FEATURE_COLLECTION","features","clearChangedIds"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@mapbox/mapbox-gl-draw/src/render.js"],"sourcesContent":["import * as Constants from './constants.js';\n\nexport default function render() {\n  // eslint-disable-next-line no-invalid-this\n  const store = this;\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n\n  const mode = store.ctx.events.currentModeName();\n\n  store.ctx.ui.queueMapClasses({ mode });\n\n  let newHotIds = [];\n  let newColdIds = [];\n\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\n    newColdIds = store.sources.hot.filter(geojson => geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined).map(geojson => geojson.properties.id);\n  }\n\n  store.sources.hot = [];\n  const lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {\n    const id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\n\n  function renderFeature(id, source) {\n    const feature = store.get(id);\n    const featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, (geojson) => {\n      geojson.properties.mode = mode;\n      store.sources[source].push(geojson);\n    });\n  }\n\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n\n  cleanup();\n\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}