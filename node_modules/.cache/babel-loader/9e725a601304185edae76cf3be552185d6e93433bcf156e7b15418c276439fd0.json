{"ast":null,"code":"import Feature from './feature.js';\nconst Polygon = function (ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n  this.coordinates = this.coordinates.map(ring => ring.slice(0, -1));\n};\nPolygon.prototype = Object.create(Feature.prototype);\nPolygon.prototype.isValid = function () {\n  if (this.coordinates.length === 0) return false;\n  return this.coordinates.every(ring => ring.length > 2);\n};\n\n// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.\nPolygon.prototype.incomingCoords = function (coords) {\n  this.coordinates = coords.map(ring => ring.slice(0, -1));\n  this.changed();\n};\n\n// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.\nPolygon.prototype.setCoordinates = function (coords) {\n  this.coordinates = coords;\n  this.changed();\n};\nPolygon.prototype.addCoordinate = function (path, lng, lat) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  ring.splice(ids[1], 0, [lng, lat]);\n};\nPolygon.prototype.removeCoordinate = function (path) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  if (ring) {\n    ring.splice(ids[1], 1);\n    if (ring.length < 3) {\n      this.coordinates.splice(ids[0], 1);\n    }\n  }\n};\nPolygon.prototype.getCoordinate = function (path) {\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  return JSON.parse(JSON.stringify(ring[ids[1]]));\n};\nPolygon.prototype.getCoordinates = function () {\n  return this.coordinates.map(coords => coords.concat([coords[0]]));\n};\nPolygon.prototype.updateCoordinate = function (path, lng, lat) {\n  this.changed();\n  const parts = path.split('.');\n  const ringId = parseInt(parts[0], 10);\n  const coordId = parseInt(parts[1], 10);\n  if (this.coordinates[ringId] === undefined) {\n    this.coordinates[ringId] = [];\n  }\n  this.coordinates[ringId][coordId] = [lng, lat];\n};\nexport default Polygon;","map":{"version":3,"names":["Feature","Polygon","ctx","geojson","call","coordinates","map","ring","slice","prototype","Object","create","isValid","length","every","incomingCoords","coords","changed","setCoordinates","addCoordinate","path","lng","lat","ids","split","x","parseInt","splice","removeCoordinate","getCoordinate","JSON","parse","stringify","getCoordinates","concat","updateCoordinate","parts","ringId","coordId","undefined"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js"],"sourcesContent":["import Feature from './feature.js';\n\nconst Polygon = function(ctx, geojson) {\n  Feature.call(this, ctx, geojson);\n  this.coordinates = this.coordinates.map(ring => ring.slice(0, -1));\n};\n\nPolygon.prototype = Object.create(Feature.prototype);\n\nPolygon.prototype.isValid = function() {\n  if (this.coordinates.length === 0) return false;\n  return this.coordinates.every(ring => ring.length > 2);\n};\n\n// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.\nPolygon.prototype.incomingCoords = function(coords) {\n  this.coordinates = coords.map(ring => ring.slice(0, -1));\n  this.changed();\n};\n\n// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.\nPolygon.prototype.setCoordinates = function(coords) {\n  this.coordinates = coords;\n  this.changed();\n};\n\nPolygon.prototype.addCoordinate = function(path, lng, lat) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n\n  const ring = this.coordinates[ids[0]];\n\n  ring.splice(ids[1], 0, [lng, lat]);\n};\n\nPolygon.prototype.removeCoordinate = function(path) {\n  this.changed();\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  if (ring) {\n    ring.splice(ids[1], 1);\n    if (ring.length < 3) {\n      this.coordinates.splice(ids[0], 1);\n    }\n  }\n};\n\nPolygon.prototype.getCoordinate = function(path) {\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const ring = this.coordinates[ids[0]];\n  return JSON.parse(JSON.stringify(ring[ids[1]]));\n};\n\nPolygon.prototype.getCoordinates = function() {\n  return this.coordinates.map(coords => coords.concat([coords[0]]));\n};\n\nPolygon.prototype.updateCoordinate = function(path, lng, lat) {\n  this.changed();\n  const parts = path.split('.');\n  const ringId = parseInt(parts[0], 10);\n  const coordId = parseInt(parts[1], 10);\n\n  if (this.coordinates[ringId] === undefined) {\n    this.coordinates[ringId] = [];\n  }\n\n  this.coordinates[ringId][coordId] = [lng, lat];\n};\n\nexport default Polygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}