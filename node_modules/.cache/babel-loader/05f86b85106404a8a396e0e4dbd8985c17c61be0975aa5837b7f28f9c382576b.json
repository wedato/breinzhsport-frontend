{"ast":null,"code":"\"use strict\";\n\n/**\n * Capture module.\n * @module capture\n */\nvar contextUtils = require('./context_utils');\nvar logger = require('./logger');\n/**\n * Wrap to automatically capture information for the segment.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Can take a single 'subsegment' argument.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureFunc\n * @return {*} - Returns the result if any by executing the provided function.\n */\nvar captureFunc = function captureFunc(name, fcn, parent) {\n  validate(name, fcn);\n  var current, executeFcn;\n  var parentSeg = contextUtils.resolveSegment(parent);\n  if (!parentSeg) {\n    logger.getLogger().warn('Failed to capture function.');\n    return fcn();\n  }\n  current = parentSeg.addNewSubsegment(name);\n  executeFcn = captureFcn(fcn, current);\n  try {\n    const response = executeFcn(current);\n    current.close();\n    return response;\n  } catch (e) {\n    current.close(e);\n    throw e;\n  }\n};\n/**\n * Wrap to automatically capture information for the sub/segment.  You must close the segment\n * manually from within the function.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Must take a single 'subsegment' argument and call 'subsegment.close([optional error])' when the async function completes.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureAsyncFunc\n * @return {*} - Returns a promise by executing the provided async function.\n */\nvar captureAsyncFunc = function captureAsyncFunc(name, fcn, parent) {\n  validate(name, fcn);\n  var current, executeFcn;\n  var parentSeg = contextUtils.resolveSegment(parent);\n  if (!parentSeg) {\n    logger.getLogger().warn('Failed to capture async function.');\n    return fcn();\n  }\n  current = parentSeg.addNewSubsegment(name);\n  executeFcn = captureFcn(fcn, current);\n  try {\n    return executeFcn(current);\n  } catch (e) {\n    current.close(e);\n    throw e;\n  }\n};\n/**\n * Wrap to automatically capture information for the sub/segment. This wraps the callback and returns a function.\n * when executed, all arguments are passed through accordingly. An additional argument is appended to gain access to the newly created subsegment.\n * For this reason, always call the captured callback with the full list of arguments.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Can take a single 'subsegment' argument.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureCallbackFunc\n */\nvar captureCallbackFunc = function captureCallbackFunc(name, fcn, parent) {\n  validate(name, fcn);\n  var base = contextUtils.resolveSegment(parent);\n  if (!base) {\n    logger.getLogger().warn('Failed to capture callback function.');\n    return fcn;\n  }\n  base.incrementCounter();\n  return function () {\n    var parentSeg = contextUtils.resolveSegment(parent);\n    var args = Array.prototype.slice.call(arguments);\n    captureFunc(name, fcn.bind.apply(fcn, [null].concat(args)), parentSeg);\n    base.decrementCounter();\n  }.bind(this);\n};\nfunction captureFcn(fcn, current) {\n  var executeFcn;\n  if (contextUtils.isAutomaticMode()) {\n    var session = contextUtils.getNamespace();\n    var contextFcn = function () {\n      var value;\n      session.run(function () {\n        contextUtils.setSegment(current);\n        value = fcn(current);\n      });\n      return value;\n    };\n    executeFcn = contextFcn;\n  } else {\n    executeFcn = fcn;\n  }\n  return executeFcn;\n}\nfunction validate(name, fcn) {\n  var error;\n  if (!name || typeof name !== 'string') {\n    error = 'Param \"name\" must be a non-empty string.';\n    logger.getLogger().error(error);\n    throw new Error(error);\n  } else if (typeof fcn !== 'function') {\n    error = 'Param \"fcn\" must be a function.';\n    logger.getLogger().error(error);\n    throw new Error(error);\n  }\n}\nmodule.exports.captureFunc = captureFunc;\nmodule.exports.captureAsyncFunc = captureAsyncFunc;\nmodule.exports.captureCallbackFunc = captureCallbackFunc;","map":{"version":3,"names":["contextUtils","require","logger","captureFunc","name","fcn","parent","validate","current","executeFcn","parentSeg","resolveSegment","getLogger","warn","addNewSubsegment","captureFcn","response","close","e","captureAsyncFunc","captureCallbackFunc","base","incrementCounter","args","Array","prototype","slice","call","arguments","bind","apply","concat","decrementCounter","isAutomaticMode","session","getNamespace","contextFcn","value","run","setSegment","error","Error","module","exports"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/capture.js"],"sourcesContent":["\"use strict\";\n/**\n * Capture module.\n * @module capture\n */\nvar contextUtils = require('./context_utils');\nvar logger = require('./logger');\n/**\n * Wrap to automatically capture information for the segment.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Can take a single 'subsegment' argument.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureFunc\n * @return {*} - Returns the result if any by executing the provided function.\n */\nvar captureFunc = function captureFunc(name, fcn, parent) {\n    validate(name, fcn);\n    var current, executeFcn;\n    var parentSeg = contextUtils.resolveSegment(parent);\n    if (!parentSeg) {\n        logger.getLogger().warn('Failed to capture function.');\n        return fcn();\n    }\n    current = parentSeg.addNewSubsegment(name);\n    executeFcn = captureFcn(fcn, current);\n    try {\n        const response = executeFcn(current);\n        current.close();\n        return response;\n    }\n    catch (e) {\n        current.close(e);\n        throw (e);\n    }\n};\n/**\n * Wrap to automatically capture information for the sub/segment.  You must close the segment\n * manually from within the function.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Must take a single 'subsegment' argument and call 'subsegment.close([optional error])' when the async function completes.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureAsyncFunc\n * @return {*} - Returns a promise by executing the provided async function.\n */\nvar captureAsyncFunc = function captureAsyncFunc(name, fcn, parent) {\n    validate(name, fcn);\n    var current, executeFcn;\n    var parentSeg = contextUtils.resolveSegment(parent);\n    if (!parentSeg) {\n        logger.getLogger().warn('Failed to capture async function.');\n        return fcn();\n    }\n    current = parentSeg.addNewSubsegment(name);\n    executeFcn = captureFcn(fcn, current);\n    try {\n        return executeFcn(current);\n    }\n    catch (e) {\n        current.close(e);\n        throw (e);\n    }\n};\n/**\n * Wrap to automatically capture information for the sub/segment. This wraps the callback and returns a function.\n * when executed, all arguments are passed through accordingly. An additional argument is appended to gain access to the newly created subsegment.\n * For this reason, always call the captured callback with the full list of arguments.\n * @param {string} name - The name of the new subsegment.\n * @param {function} fcn - The function context to wrap. Can take a single 'subsegment' argument.\n * @param {Segment|Subsegment} [parent] - The parent for the new subsegment, for manual mode.\n * @alias module:capture.captureCallbackFunc\n */\nvar captureCallbackFunc = function captureCallbackFunc(name, fcn, parent) {\n    validate(name, fcn);\n    var base = contextUtils.resolveSegment(parent);\n    if (!base) {\n        logger.getLogger().warn('Failed to capture callback function.');\n        return fcn;\n    }\n    base.incrementCounter();\n    return function () {\n        var parentSeg = contextUtils.resolveSegment(parent);\n        var args = Array.prototype.slice.call(arguments);\n        captureFunc(name, fcn.bind.apply(fcn, [null].concat(args)), parentSeg);\n        base.decrementCounter();\n    }.bind(this);\n};\nfunction captureFcn(fcn, current) {\n    var executeFcn;\n    if (contextUtils.isAutomaticMode()) {\n        var session = contextUtils.getNamespace();\n        var contextFcn = function () {\n            var value;\n            session.run(function () {\n                contextUtils.setSegment(current);\n                value = fcn(current);\n            });\n            return value;\n        };\n        executeFcn = contextFcn;\n    }\n    else {\n        executeFcn = fcn;\n    }\n    return executeFcn;\n}\nfunction validate(name, fcn) {\n    var error;\n    if (!name || typeof name !== 'string') {\n        error = 'Param \"name\" must be a non-empty string.';\n        logger.getLogger().error(error);\n        throw new Error(error);\n    }\n    else if (typeof fcn !== 'function') {\n        error = 'Param \"fcn\" must be a function.';\n        logger.getLogger().error(error);\n        throw new Error(error);\n    }\n}\nmodule.exports.captureFunc = captureFunc;\nmodule.exports.captureAsyncFunc = captureAsyncFunc;\nmodule.exports.captureCallbackFunc = captureCallbackFunc;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}