{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar $Number = GetIntrinsic('%Number%');\nvar $BigInt = GetIntrinsic('%BigInt%', true);\nmodule.exports = function integerToNBytes(intValue, n, isLittleEndian) {\n  var Z = typeof intValue === 'bigint' ? $BigInt : $Number;\n  /*\n  if (intValue >= 0) { // step 3.d\n  \t// Let rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.\n  } else { // step 3.e\n  \t// Let rawBytes be a List containing the n-byte binary 2's complement encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.\n  }\n     */\n  if (intValue < 0) {\n    intValue >>>= 0; // eslint-disable-line no-param-reassign\n  }\n  var rawBytes = [];\n  for (var i = 0; i < n; i++) {\n    rawBytes[isLittleEndian ? i : n - 1 - i] = $Number(intValue & Z(0xFF));\n    intValue >>= Z(8); // eslint-disable-line no-param-reassign\n  }\n  return rawBytes; // step 4\n};","map":{"version":3,"names":["GetIntrinsic","require","$Number","$BigInt","module","exports","integerToNBytes","intValue","n","isLittleEndian","Z","rawBytes","i"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/es-abstract/helpers/integerToNBytes.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $BigInt = GetIntrinsic('%BigInt%', true);\n\nmodule.exports = function integerToNBytes(intValue, n, isLittleEndian) {\n\tvar Z = typeof intValue === 'bigint' ? $BigInt : $Number;\n\t/*\n\tif (intValue >= 0) { // step 3.d\n\t\t// Let rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.\n\t} else { // step 3.e\n\t\t// Let rawBytes be a List containing the n-byte binary 2's complement encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.\n\t}\n    */\n\tif (intValue < 0) {\n\t\tintValue >>>= 0; // eslint-disable-line no-param-reassign\n\t}\n\n\tvar rawBytes = [];\n\tfor (var i = 0; i < n; i++) {\n\t\trawBytes[isLittleEndian ? i : n - 1 - i] = $Number(intValue & Z(0xFF));\n\t\tintValue >>= Z(8); // eslint-disable-line no-param-reassign\n\t}\n\n\treturn rawBytes; // step 4\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAE3C,IAAIC,OAAO,GAAGF,YAAY,CAAC,UAAU,CAAC;AACtC,IAAIG,OAAO,GAAGH,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC;AAE5CI,MAAM,CAACC,OAAO,GAAG,SAASC,eAAeA,CAACC,QAAQ,EAAEC,CAAC,EAAEC,cAAc,EAAE;EACtE,IAAIC,CAAC,GAAG,OAAOH,QAAQ,KAAK,QAAQ,GAAGJ,OAAO,GAAGD,OAAO;EACxD;AACD;AACA;AACA;AACA;AACA;AACA;EACC,IAAIK,QAAQ,GAAG,CAAC,EAAE;IACjBA,QAAQ,MAAM,CAAC,CAAC,CAAC;EAClB;EAEA,IAAII,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,CAAC,EAAEI,CAAC,EAAE,EAAE;IAC3BD,QAAQ,CAACF,cAAc,GAAGG,CAAC,GAAGJ,CAAC,GAAG,CAAC,GAAGI,CAAC,CAAC,GAAGV,OAAO,CAACK,QAAQ,GAAGG,CAAC,CAAC,IAAI,CAAC,CAAC;IACtEH,QAAQ,KAAKG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpB;EAEA,OAAOC,QAAQ,CAAC,CAAC;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}