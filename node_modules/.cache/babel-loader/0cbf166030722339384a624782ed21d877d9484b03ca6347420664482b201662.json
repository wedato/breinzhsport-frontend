{"ast":null,"code":"\"use strict\";\n\n/**\n * @module utils\n */\nvar crypto = require('crypto');\nvar logger = require('./logger');\nvar TraceID = require('./segments/attributes/trace_id');\nvar utils = {\n  /**\n   * Checks a HTTP response code, where 4xx are 'error' and 5xx are 'fault'.\n   * @param {string} status - the HTTP response status code.\n   * @returns [string] - 'error', 'fault' or nothing on no match\n   * @alias module:utils.getCauseTypeFromHttpStatus\n   */\n  getCauseTypeFromHttpStatus: function getCauseTypeFromHttpStatus(status) {\n    var stat = status.toString();\n    if (stat.match(/^[4][0-9]{2}$/) !== null) {\n      return 'error';\n    } else if (stat.match(/^[5][0-9]{2}$/) !== null) {\n      return 'fault';\n    }\n  },\n  /**\n   * Removes the query string parameters from a given http request path\n   * as it may contain sensitive information\n   *\n   * Related issue: https://github.com/aws/aws-xray-sdk-node/issues/246\n   *\n   * Node documentation: https://nodejs.org/api/http.html#http_http_request_url_options_callback\n   *\n   * @param {string} path - options.path in a http.request callback\n   * @returns [string] - removes query string element from path\n   * @alias module:utils.stripQueryStringFromPath\n   */\n  stripQueryStringFromPath: function stripQueryStringFromPath(path) {\n    return path ? path.split('?')[0] : '';\n  },\n  /**\n   * Performs a case-insensitive wildcard match against two strings. This method works with pseduo-regex chars; specifically ? and * are supported.\n   *   An asterisk (*) represents any combination of characters\n   *   A question mark (?) represents any single character\n   *\n   * @param {string} pattern - the regex-like pattern to be compared against.\n   * @param {string} text - the string to compare against the pattern.\n   * @returns boolean\n   * @alias module:utils.wildcardMatch\n   */\n  wildcardMatch: function wildcardMatch(pattern, text) {\n    if (pattern === undefined || text === undefined) {\n      return false;\n    }\n    if (pattern.length === 1 && pattern.charAt(0) === '*') {\n      return true;\n    }\n    var patternLength = pattern.length;\n    var textLength = text.length;\n    var indexOfGlob = pattern.indexOf('*');\n    pattern = pattern.toLowerCase();\n    text = text.toLowerCase();\n    // Infix globs are relatively rare, and the below search is expensive especially when\n    // Balsa is used a lot. Check for infix globs and, in their absence, do the simple thing\n    if (indexOfGlob === -1 || indexOfGlob === patternLength - 1) {\n      var match = function simpleWildcardMatch() {\n        var j = 0;\n        for (var i = 0; i < patternLength; i++) {\n          var patternChar = pattern.charAt(i);\n          if (patternChar === '*') {\n            // Presumption for this method is that globs only occur at end\n            return true;\n          } else if (patternChar === '?') {\n            if (j === textLength) {\n              return false;\n            } // No character to match\n            j++;\n          } else {\n            if (j >= textLength || patternChar != text.charAt(j)) {\n              return false;\n            }\n            j++;\n          }\n        }\n        // Ate up all the pattern and didn't end at a glob, so a match will have consumed all\n        // the text\n        return j === textLength;\n      };\n      return match();\n    }\n    /*\n     * The matchArray[i] is used to record if there is a match between the first i chars in =\n     * text and the first j chars in pattern.\n     * So will return matchArray[textLength+1] in the end\n     * Loop from the beginning of the pattern\n     * case not '*': if text[i]==pattern[j] or pattern[j] is '?', and matchArray[i] is true,\n     *   set matchArray[i+1] to true, otherwise false\n     * case '*': since '*' can match any globing, as long as there is a true in matchArray before i\n     *   all the matchArray[i+1], matchArray[i+2],...,matchArray[textLength] could be true\n    */\n    var matchArray = [];\n    matchArray[0] = true;\n    for (var j = 0; j < patternLength; j++) {\n      var i;\n      var patternChar = pattern.charAt(j);\n      if (patternChar != '*') {\n        for (i = textLength - 1; i >= 0; i--) {\n          matchArray[i + 1] = !!matchArray[i] && (patternChar === '?' || patternChar === text.charAt(i));\n        }\n      } else {\n        i = 0;\n        while (i <= textLength && !matchArray[i]) {\n          i++;\n        }\n        for (i; i <= textLength; i++) {\n          matchArray[i] = true;\n        }\n      }\n      matchArray[0] = matchArray[0] && patternChar === '*';\n    }\n    return matchArray[textLength];\n  },\n  LambdaUtils: {\n    validTraceData: function (xAmznTraceId) {\n      var valid = false;\n      if (xAmznTraceId) {\n        var data = utils.processTraceData(xAmznTraceId);\n        valid = !!(data && data.root && data.parent && data.sampled);\n      }\n      return valid;\n    },\n    /**\n     * Populates trace ID, parent ID, and sampled decision of given segment. Will always populate valid values,\n     * even if xAmznTraceId contains missing or invalid values. This ensures downstream services receive valid\n     * headers.\n     * @param {Segment} segment - Facade segment to be populated\n     * @param {String} xAmznTraceId - Raw Trace Header to supply trace data\n     * @returns {Boolean} - true if required fields are present and Trace ID is valid, false otherwise\n     */\n    populateTraceData: function (segment, xAmznTraceId) {\n      logger.getLogger().debug('Lambda trace data found: ' + xAmznTraceId);\n      let traceData = utils.processTraceData(xAmznTraceId);\n      var valid = false;\n      if (!traceData) {\n        traceData = {};\n        logger.getLogger().error('_X_AMZN_TRACE_ID is empty or has an invalid format');\n      } else if (traceData.root && !traceData.parent && !traceData.sampled) {\n        // Lambda PassThrough only has root, treat as valid in this case and mark the segment\n        segment.noOp = true;\n        valid = true;\n      } else if (!traceData.root || !traceData.parent || !traceData.sampled) {\n        logger.getLogger().error('_X_AMZN_TRACE_ID is missing required information');\n      } else {\n        valid = true;\n      }\n      segment.trace_id = TraceID.FromString(traceData.root).toString(); // Will always assign valid trace_id\n      segment.id = traceData.parent || crypto.randomBytes(8).toString('hex');\n      if (traceData.root && segment.trace_id !== traceData.root) {\n        logger.getLogger().error('_X_AMZN_TRACE_ID contains invalid trace ID');\n        valid = false;\n      }\n      if (!parseInt(traceData.sampled)) {\n        segment.notTraced = true;\n      } else {\n        delete segment.notTraced;\n      }\n      if (traceData.data) {\n        segment.additionalTraceData = traceData.data;\n      }\n      logger.getLogger().debug('Segment started: ' + JSON.stringify(traceData));\n      return valid;\n    }\n  },\n  /**\n   * Splits out the data from the trace id format.  Used by the middleware.\n   * @param {String} traceData - The additional trace data (typically in req.headers.x-amzn-trace-id).\n   * @returns {object}\n   * @alias module:mw_utils.processTraceData\n   */\n  processTraceData: function processTraceData(traceData) {\n    var amznTraceData = {};\n    var data = {};\n    var reservedKeywords = ['root', 'parent', 'sampled', 'self'];\n    var remainingBytes = 256;\n    if (!(typeof traceData === 'string' && traceData)) {\n      return amznTraceData;\n    }\n    traceData.split(';').forEach(function (header) {\n      if (!header) {\n        return;\n      }\n      var pair = header.split('=');\n      if (pair[0] && pair[1]) {\n        let key = pair[0].trim();\n        let value = pair[1].trim();\n        let lowerCaseKey = key.toLowerCase();\n        let reserved = reservedKeywords.indexOf(lowerCaseKey) !== -1;\n        if (reserved) {\n          amznTraceData[lowerCaseKey] = value;\n        } else if (!reserved && remainingBytes - (lowerCaseKey.length + value.length) >= 0) {\n          data[key] = value;\n          remainingBytes -= key.length + value.length;\n        }\n      }\n    });\n    amznTraceData['data'] = data;\n    return amznTraceData;\n  },\n  /**\n   * Makes a shallow copy of an object without given keys - keeps prototype\n   * @param {Object} obj - The object to copy\n   * @param {string[]} [keys=[]] - The keys that won't be copied\n   * @param {boolean} [preservePrototype=false] - If true also copy prototype properties\n   * @returns {}\n   */\n  objectWithoutProperties: function objectWithoutProperties(obj, keys, preservePrototype) {\n    keys = Array.isArray(keys) ? keys : [];\n    preservePrototype = typeof preservePrototype === 'boolean' ? preservePrototype : false;\n    var target = preservePrototype ? Object.create(Object.getPrototypeOf(obj)) : {};\n    for (var property in obj) {\n      if (keys.indexOf(property) >= 0) {\n        continue;\n      }\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) {\n        continue;\n      }\n      target[property] = obj[property];\n    }\n    return target;\n  },\n  /**\n   * Safely gets an integer from a string or number\n   * @param {String | Number} - input to cast to integer\n   * @returns {Number} - Integer representation of input, or 0 if input is not castable to int\n   */\n  safeParseInt: val => {\n    if (!val || isNaN(val)) {\n      return 0;\n    }\n    return parseInt(val);\n  }\n};\nmodule.exports = utils;","map":{"version":3,"names":["crypto","require","logger","TraceID","utils","getCauseTypeFromHttpStatus","status","stat","toString","match","stripQueryStringFromPath","path","split","wildcardMatch","pattern","text","undefined","length","charAt","patternLength","textLength","indexOfGlob","indexOf","toLowerCase","simpleWildcardMatch","j","i","patternChar","matchArray","LambdaUtils","validTraceData","xAmznTraceId","valid","data","processTraceData","root","parent","sampled","populateTraceData","segment","getLogger","debug","traceData","error","noOp","trace_id","FromString","id","randomBytes","parseInt","notTraced","additionalTraceData","JSON","stringify","amznTraceData","reservedKeywords","remainingBytes","forEach","header","pair","key","trim","value","lowerCaseKey","reserved","objectWithoutProperties","obj","keys","preservePrototype","Array","isArray","target","Object","create","getPrototypeOf","property","prototype","hasOwnProperty","call","safeParseInt","val","isNaN","module","exports"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/utils.js"],"sourcesContent":["\"use strict\";\n/**\n * @module utils\n */\nvar crypto = require('crypto');\nvar logger = require('./logger');\nvar TraceID = require('./segments/attributes/trace_id');\nvar utils = {\n    /**\n     * Checks a HTTP response code, where 4xx are 'error' and 5xx are 'fault'.\n     * @param {string} status - the HTTP response status code.\n     * @returns [string] - 'error', 'fault' or nothing on no match\n     * @alias module:utils.getCauseTypeFromHttpStatus\n     */\n    getCauseTypeFromHttpStatus: function getCauseTypeFromHttpStatus(status) {\n        var stat = status.toString();\n        if (stat.match(/^[4][0-9]{2}$/) !== null) {\n            return 'error';\n        }\n        else if (stat.match(/^[5][0-9]{2}$/) !== null) {\n            return 'fault';\n        }\n    },\n    /**\n     * Removes the query string parameters from a given http request path\n     * as it may contain sensitive information\n     *\n     * Related issue: https://github.com/aws/aws-xray-sdk-node/issues/246\n     *\n     * Node documentation: https://nodejs.org/api/http.html#http_http_request_url_options_callback\n     *\n     * @param {string} path - options.path in a http.request callback\n     * @returns [string] - removes query string element from path\n     * @alias module:utils.stripQueryStringFromPath\n     */\n    stripQueryStringFromPath: function stripQueryStringFromPath(path) {\n        return path ? path.split('?')[0] : '';\n    },\n    /**\n     * Performs a case-insensitive wildcard match against two strings. This method works with pseduo-regex chars; specifically ? and * are supported.\n     *   An asterisk (*) represents any combination of characters\n     *   A question mark (?) represents any single character\n     *\n     * @param {string} pattern - the regex-like pattern to be compared against.\n     * @param {string} text - the string to compare against the pattern.\n     * @returns boolean\n     * @alias module:utils.wildcardMatch\n     */\n    wildcardMatch: function wildcardMatch(pattern, text) {\n        if (pattern === undefined || text === undefined) {\n            return false;\n        }\n        if (pattern.length === 1 && pattern.charAt(0) === '*') {\n            return true;\n        }\n        var patternLength = pattern.length;\n        var textLength = text.length;\n        var indexOfGlob = pattern.indexOf('*');\n        pattern = pattern.toLowerCase();\n        text = text.toLowerCase();\n        // Infix globs are relatively rare, and the below search is expensive especially when\n        // Balsa is used a lot. Check for infix globs and, in their absence, do the simple thing\n        if (indexOfGlob === -1 || indexOfGlob === (patternLength - 1)) {\n            var match = function simpleWildcardMatch() {\n                var j = 0;\n                for (var i = 0; i < patternLength; i++) {\n                    var patternChar = pattern.charAt(i);\n                    if (patternChar === '*') {\n                        // Presumption for this method is that globs only occur at end\n                        return true;\n                    }\n                    else if (patternChar === '?') {\n                        if (j === textLength) {\n                            return false;\n                        } // No character to match\n                        j++;\n                    }\n                    else {\n                        if (j >= textLength || patternChar != text.charAt(j)) {\n                            return false;\n                        }\n                        j++;\n                    }\n                }\n                // Ate up all the pattern and didn't end at a glob, so a match will have consumed all\n                // the text\n                return j === textLength;\n            };\n            return match();\n        }\n        /*\n         * The matchArray[i] is used to record if there is a match between the first i chars in =\n         * text and the first j chars in pattern.\n         * So will return matchArray[textLength+1] in the end\n         * Loop from the beginning of the pattern\n         * case not '*': if text[i]==pattern[j] or pattern[j] is '?', and matchArray[i] is true,\n         *   set matchArray[i+1] to true, otherwise false\n         * case '*': since '*' can match any globing, as long as there is a true in matchArray before i\n         *   all the matchArray[i+1], matchArray[i+2],...,matchArray[textLength] could be true\n        */\n        var matchArray = [];\n        matchArray[0] = true;\n        for (var j = 0; j < patternLength; j++) {\n            var i;\n            var patternChar = pattern.charAt(j);\n            if (patternChar != '*') {\n                for (i = textLength - 1; i >= 0; i--) {\n                    matchArray[i + 1] = !!matchArray[i] && (patternChar === '?' || (patternChar === text.charAt(i)));\n                }\n            }\n            else {\n                i = 0;\n                while (i <= textLength && !matchArray[i]) {\n                    i++;\n                }\n                for (i; i <= textLength; i++) {\n                    matchArray[i] = true;\n                }\n            }\n            matchArray[0] = (matchArray[0] && patternChar === '*');\n        }\n        return matchArray[textLength];\n    },\n    LambdaUtils: {\n        validTraceData: function (xAmznTraceId) {\n            var valid = false;\n            if (xAmznTraceId) {\n                var data = utils.processTraceData(xAmznTraceId);\n                valid = !!(data && data.root && data.parent && data.sampled);\n            }\n            return valid;\n        },\n        /**\n         * Populates trace ID, parent ID, and sampled decision of given segment. Will always populate valid values,\n         * even if xAmznTraceId contains missing or invalid values. This ensures downstream services receive valid\n         * headers.\n         * @param {Segment} segment - Facade segment to be populated\n         * @param {String} xAmznTraceId - Raw Trace Header to supply trace data\n         * @returns {Boolean} - true if required fields are present and Trace ID is valid, false otherwise\n         */\n        populateTraceData: function (segment, xAmznTraceId) {\n            logger.getLogger().debug('Lambda trace data found: ' + xAmznTraceId);\n            let traceData = utils.processTraceData(xAmznTraceId);\n            var valid = false;\n            if (!traceData) {\n                traceData = {};\n                logger.getLogger().error('_X_AMZN_TRACE_ID is empty or has an invalid format');\n            }\n            else if (traceData.root && !traceData.parent && !traceData.sampled) {\n                // Lambda PassThrough only has root, treat as valid in this case and mark the segment\n                segment.noOp = true;\n                valid = true;\n            }\n            else if (!traceData.root || !traceData.parent || !traceData.sampled) {\n                logger.getLogger().error('_X_AMZN_TRACE_ID is missing required information');\n            }\n            else {\n                valid = true;\n            }\n            segment.trace_id = TraceID.FromString(traceData.root).toString(); // Will always assign valid trace_id\n            segment.id = traceData.parent || crypto.randomBytes(8).toString('hex');\n            if (traceData.root && segment.trace_id !== traceData.root) {\n                logger.getLogger().error('_X_AMZN_TRACE_ID contains invalid trace ID');\n                valid = false;\n            }\n            if (!parseInt(traceData.sampled)) {\n                segment.notTraced = true;\n            }\n            else {\n                delete segment.notTraced;\n            }\n            if (traceData.data) {\n                segment.additionalTraceData = traceData.data;\n            }\n            logger.getLogger().debug('Segment started: ' + JSON.stringify(traceData));\n            return valid;\n        }\n    },\n    /**\n     * Splits out the data from the trace id format.  Used by the middleware.\n     * @param {String} traceData - The additional trace data (typically in req.headers.x-amzn-trace-id).\n     * @returns {object}\n     * @alias module:mw_utils.processTraceData\n     */\n    processTraceData: function processTraceData(traceData) {\n        var amznTraceData = {};\n        var data = {};\n        var reservedKeywords = ['root', 'parent', 'sampled', 'self'];\n        var remainingBytes = 256;\n        if (!(typeof traceData === 'string' && traceData)) {\n            return amznTraceData;\n        }\n        traceData.split(';').forEach(function (header) {\n            if (!header) {\n                return;\n            }\n            var pair = header.split('=');\n            if (pair[0] && pair[1]) {\n                let key = pair[0].trim();\n                let value = pair[1].trim();\n                let lowerCaseKey = key.toLowerCase();\n                let reserved = reservedKeywords.indexOf(lowerCaseKey) !== -1;\n                if (reserved) {\n                    amznTraceData[lowerCaseKey] = value;\n                }\n                else if (!reserved && remainingBytes - (lowerCaseKey.length + value.length) >= 0) {\n                    data[key] = value;\n                    remainingBytes -= (key.length + value.length);\n                }\n            }\n        });\n        amznTraceData['data'] = data;\n        return amznTraceData;\n    },\n    /**\n     * Makes a shallow copy of an object without given keys - keeps prototype\n     * @param {Object} obj - The object to copy\n     * @param {string[]} [keys=[]] - The keys that won't be copied\n     * @param {boolean} [preservePrototype=false] - If true also copy prototype properties\n     * @returns {}\n     */\n    objectWithoutProperties: function objectWithoutProperties(obj, keys, preservePrototype) {\n        keys = Array.isArray(keys) ? keys : [];\n        preservePrototype = typeof preservePrototype === 'boolean' ? preservePrototype : false;\n        var target = preservePrototype ? Object.create(Object.getPrototypeOf(obj)) : {};\n        for (var property in obj) {\n            if (keys.indexOf(property) >= 0) {\n                continue;\n            }\n            if (!Object.prototype.hasOwnProperty.call(obj, property)) {\n                continue;\n            }\n            target[property] = obj[property];\n        }\n        return target;\n    },\n    /**\n     * Safely gets an integer from a string or number\n     * @param {String | Number} - input to cast to integer\n     * @returns {Number} - Integer representation of input, or 0 if input is not castable to int\n     */\n    safeParseInt: (val) => {\n        if (!val || isNaN(val)) {\n            return 0;\n        }\n        return parseInt(val);\n    }\n};\nmodule.exports = utils;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIE,OAAO,GAAGF,OAAO,CAAC,gCAAgC,CAAC;AACvD,IAAIG,KAAK,GAAG;EACR;AACJ;AACA;AACA;AACA;AACA;EACIC,0BAA0B,EAAE,SAASA,0BAA0BA,CAACC,MAAM,EAAE;IACpE,IAAIC,IAAI,GAAGD,MAAM,CAACE,QAAQ,CAAC,CAAC;IAC5B,IAAID,IAAI,CAACE,KAAK,CAAC,eAAe,CAAC,KAAK,IAAI,EAAE;MACtC,OAAO,OAAO;IAClB,CAAC,MACI,IAAIF,IAAI,CAACE,KAAK,CAAC,eAAe,CAAC,KAAK,IAAI,EAAE;MAC3C,OAAO,OAAO;IAClB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,wBAAwB,EAAE,SAASA,wBAAwBA,CAACC,IAAI,EAAE;IAC9D,OAAOA,IAAI,GAAGA,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;EACzC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAa,EAAE,SAASA,aAAaA,CAACC,OAAO,EAAEC,IAAI,EAAE;IACjD,IAAID,OAAO,KAAKE,SAAS,IAAID,IAAI,KAAKC,SAAS,EAAE;MAC7C,OAAO,KAAK;IAChB;IACA,IAAIF,OAAO,CAACG,MAAM,KAAK,CAAC,IAAIH,OAAO,CAACI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACnD,OAAO,IAAI;IACf;IACA,IAAIC,aAAa,GAAGL,OAAO,CAACG,MAAM;IAClC,IAAIG,UAAU,GAAGL,IAAI,CAACE,MAAM;IAC5B,IAAII,WAAW,GAAGP,OAAO,CAACQ,OAAO,CAAC,GAAG,CAAC;IACtCR,OAAO,GAAGA,OAAO,CAACS,WAAW,CAAC,CAAC;IAC/BR,IAAI,GAAGA,IAAI,CAACQ,WAAW,CAAC,CAAC;IACzB;IACA;IACA,IAAIF,WAAW,KAAK,CAAC,CAAC,IAAIA,WAAW,KAAMF,aAAa,GAAG,CAAE,EAAE;MAC3D,IAAIV,KAAK,GAAG,SAASe,mBAAmBA,CAAA,EAAG;QACvC,IAAIC,CAAC,GAAG,CAAC;QACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,aAAa,EAAEO,CAAC,EAAE,EAAE;UACpC,IAAIC,WAAW,GAAGb,OAAO,CAACI,MAAM,CAACQ,CAAC,CAAC;UACnC,IAAIC,WAAW,KAAK,GAAG,EAAE;YACrB;YACA,OAAO,IAAI;UACf,CAAC,MACI,IAAIA,WAAW,KAAK,GAAG,EAAE;YAC1B,IAAIF,CAAC,KAAKL,UAAU,EAAE;cAClB,OAAO,KAAK;YAChB,CAAC,CAAC;YACFK,CAAC,EAAE;UACP,CAAC,MACI;YACD,IAAIA,CAAC,IAAIL,UAAU,IAAIO,WAAW,IAAIZ,IAAI,CAACG,MAAM,CAACO,CAAC,CAAC,EAAE;cAClD,OAAO,KAAK;YAChB;YACAA,CAAC,EAAE;UACP;QACJ;QACA;QACA;QACA,OAAOA,CAAC,KAAKL,UAAU;MAC3B,CAAC;MACD,OAAOX,KAAK,CAAC,CAAC;IAClB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAImB,UAAU,GAAG,EAAE;IACnBA,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI;IACpB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,aAAa,EAAEM,CAAC,EAAE,EAAE;MACpC,IAAIC,CAAC;MACL,IAAIC,WAAW,GAAGb,OAAO,CAACI,MAAM,CAACO,CAAC,CAAC;MACnC,IAAIE,WAAW,IAAI,GAAG,EAAE;QACpB,KAAKD,CAAC,GAAGN,UAAU,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAClCE,UAAU,CAACF,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAACE,UAAU,CAACF,CAAC,CAAC,KAAKC,WAAW,KAAK,GAAG,IAAKA,WAAW,KAAKZ,IAAI,CAACG,MAAM,CAACQ,CAAC,CAAE,CAAC;QACpG;MACJ,CAAC,MACI;QACDA,CAAC,GAAG,CAAC;QACL,OAAOA,CAAC,IAAIN,UAAU,IAAI,CAACQ,UAAU,CAACF,CAAC,CAAC,EAAE;UACtCA,CAAC,EAAE;QACP;QACA,KAAKA,CAAC,EAAEA,CAAC,IAAIN,UAAU,EAAEM,CAAC,EAAE,EAAE;UAC1BE,UAAU,CAACF,CAAC,CAAC,GAAG,IAAI;QACxB;MACJ;MACAE,UAAU,CAAC,CAAC,CAAC,GAAIA,UAAU,CAAC,CAAC,CAAC,IAAID,WAAW,KAAK,GAAI;IAC1D;IACA,OAAOC,UAAU,CAACR,UAAU,CAAC;EACjC,CAAC;EACDS,WAAW,EAAE;IACTC,cAAc,EAAE,SAAAA,CAAUC,YAAY,EAAE;MACpC,IAAIC,KAAK,GAAG,KAAK;MACjB,IAAID,YAAY,EAAE;QACd,IAAIE,IAAI,GAAG7B,KAAK,CAAC8B,gBAAgB,CAACH,YAAY,CAAC;QAC/CC,KAAK,GAAG,CAAC,EAAEC,IAAI,IAAIA,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,MAAM,IAAIH,IAAI,CAACI,OAAO,CAAC;MAChE;MACA,OAAOL,KAAK;IAChB,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQM,iBAAiB,EAAE,SAAAA,CAAUC,OAAO,EAAER,YAAY,EAAE;MAChD7B,MAAM,CAACsC,SAAS,CAAC,CAAC,CAACC,KAAK,CAAC,2BAA2B,GAAGV,YAAY,CAAC;MACpE,IAAIW,SAAS,GAAGtC,KAAK,CAAC8B,gBAAgB,CAACH,YAAY,CAAC;MACpD,IAAIC,KAAK,GAAG,KAAK;MACjB,IAAI,CAACU,SAAS,EAAE;QACZA,SAAS,GAAG,CAAC,CAAC;QACdxC,MAAM,CAACsC,SAAS,CAAC,CAAC,CAACG,KAAK,CAAC,oDAAoD,CAAC;MAClF,CAAC,MACI,IAAID,SAAS,CAACP,IAAI,IAAI,CAACO,SAAS,CAACN,MAAM,IAAI,CAACM,SAAS,CAACL,OAAO,EAAE;QAChE;QACAE,OAAO,CAACK,IAAI,GAAG,IAAI;QACnBZ,KAAK,GAAG,IAAI;MAChB,CAAC,MACI,IAAI,CAACU,SAAS,CAACP,IAAI,IAAI,CAACO,SAAS,CAACN,MAAM,IAAI,CAACM,SAAS,CAACL,OAAO,EAAE;QACjEnC,MAAM,CAACsC,SAAS,CAAC,CAAC,CAACG,KAAK,CAAC,kDAAkD,CAAC;MAChF,CAAC,MACI;QACDX,KAAK,GAAG,IAAI;MAChB;MACAO,OAAO,CAACM,QAAQ,GAAG1C,OAAO,CAAC2C,UAAU,CAACJ,SAAS,CAACP,IAAI,CAAC,CAAC3B,QAAQ,CAAC,CAAC,CAAC,CAAC;MAClE+B,OAAO,CAACQ,EAAE,GAAGL,SAAS,CAACN,MAAM,IAAIpC,MAAM,CAACgD,WAAW,CAAC,CAAC,CAAC,CAACxC,QAAQ,CAAC,KAAK,CAAC;MACtE,IAAIkC,SAAS,CAACP,IAAI,IAAII,OAAO,CAACM,QAAQ,KAAKH,SAAS,CAACP,IAAI,EAAE;QACvDjC,MAAM,CAACsC,SAAS,CAAC,CAAC,CAACG,KAAK,CAAC,4CAA4C,CAAC;QACtEX,KAAK,GAAG,KAAK;MACjB;MACA,IAAI,CAACiB,QAAQ,CAACP,SAAS,CAACL,OAAO,CAAC,EAAE;QAC9BE,OAAO,CAACW,SAAS,GAAG,IAAI;MAC5B,CAAC,MACI;QACD,OAAOX,OAAO,CAACW,SAAS;MAC5B;MACA,IAAIR,SAAS,CAACT,IAAI,EAAE;QAChBM,OAAO,CAACY,mBAAmB,GAAGT,SAAS,CAACT,IAAI;MAChD;MACA/B,MAAM,CAACsC,SAAS,CAAC,CAAC,CAACC,KAAK,CAAC,mBAAmB,GAAGW,IAAI,CAACC,SAAS,CAACX,SAAS,CAAC,CAAC;MACzE,OAAOV,KAAK;IAChB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIE,gBAAgB,EAAE,SAASA,gBAAgBA,CAACQ,SAAS,EAAE;IACnD,IAAIY,aAAa,GAAG,CAAC,CAAC;IACtB,IAAIrB,IAAI,GAAG,CAAC,CAAC;IACb,IAAIsB,gBAAgB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC;IAC5D,IAAIC,cAAc,GAAG,GAAG;IACxB,IAAI,EAAE,OAAOd,SAAS,KAAK,QAAQ,IAAIA,SAAS,CAAC,EAAE;MAC/C,OAAOY,aAAa;IACxB;IACAZ,SAAS,CAAC9B,KAAK,CAAC,GAAG,CAAC,CAAC6C,OAAO,CAAC,UAAUC,MAAM,EAAE;MAC3C,IAAI,CAACA,MAAM,EAAE;QACT;MACJ;MACA,IAAIC,IAAI,GAAGD,MAAM,CAAC9C,KAAK,CAAC,GAAG,CAAC;MAC5B,IAAI+C,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,EAAE;QACpB,IAAIC,GAAG,GAAGD,IAAI,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QACxB,IAAIC,KAAK,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QAC1B,IAAIE,YAAY,GAAGH,GAAG,CAACrC,WAAW,CAAC,CAAC;QACpC,IAAIyC,QAAQ,GAAGT,gBAAgB,CAACjC,OAAO,CAACyC,YAAY,CAAC,KAAK,CAAC,CAAC;QAC5D,IAAIC,QAAQ,EAAE;UACVV,aAAa,CAACS,YAAY,CAAC,GAAGD,KAAK;QACvC,CAAC,MACI,IAAI,CAACE,QAAQ,IAAIR,cAAc,IAAIO,YAAY,CAAC9C,MAAM,GAAG6C,KAAK,CAAC7C,MAAM,CAAC,IAAI,CAAC,EAAE;UAC9EgB,IAAI,CAAC2B,GAAG,CAAC,GAAGE,KAAK;UACjBN,cAAc,IAAKI,GAAG,CAAC3C,MAAM,GAAG6C,KAAK,CAAC7C,MAAO;QACjD;MACJ;IACJ,CAAC,CAAC;IACFqC,aAAa,CAAC,MAAM,CAAC,GAAGrB,IAAI;IAC5B,OAAOqB,aAAa;EACxB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIW,uBAAuB,EAAE,SAASA,uBAAuBA,CAACC,GAAG,EAAEC,IAAI,EAAEC,iBAAiB,EAAE;IACpFD,IAAI,GAAGE,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,GAAGA,IAAI,GAAG,EAAE;IACtCC,iBAAiB,GAAG,OAAOA,iBAAiB,KAAK,SAAS,GAAGA,iBAAiB,GAAG,KAAK;IACtF,IAAIG,MAAM,GAAGH,iBAAiB,GAAGI,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAACR,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC/E,KAAK,IAAIS,QAAQ,IAAIT,GAAG,EAAE;MACtB,IAAIC,IAAI,CAAC7C,OAAO,CAACqD,QAAQ,CAAC,IAAI,CAAC,EAAE;QAC7B;MACJ;MACA,IAAI,CAACH,MAAM,CAACI,SAAS,CAACC,cAAc,CAACC,IAAI,CAACZ,GAAG,EAAES,QAAQ,CAAC,EAAE;QACtD;MACJ;MACAJ,MAAM,CAACI,QAAQ,CAAC,GAAGT,GAAG,CAACS,QAAQ,CAAC;IACpC;IACA,OAAOJ,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIQ,YAAY,EAAGC,GAAG,IAAK;IACnB,IAAI,CAACA,GAAG,IAAIC,KAAK,CAACD,GAAG,CAAC,EAAE;MACpB,OAAO,CAAC;IACZ;IACA,OAAO/B,QAAQ,CAAC+B,GAAG,CAAC;EACxB;AACJ,CAAC;AACDE,MAAM,CAACC,OAAO,GAAG/E,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}