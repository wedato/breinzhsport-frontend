{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar $parseInt = GetIntrinsic('%parseInt%');\nvar $abs = require('math-intrinsics/abs');\nvar $floor = require('math-intrinsics/floor');\nvar isNegativeZero = require('math-intrinsics/isNegativeZero');\nvar callBound = require('call-bound');\nvar $strIndexOf = callBound('String.prototype.indexOf');\nvar $strSlice = callBound('String.prototype.slice');\nvar fractionToBitString = require('../helpers/fractionToBinaryString');\nvar intToBinString = require('../helpers/intToBinaryString');\nvar float64bias = 1023;\nvar elevenOnes = '11111111111';\nvar elevenZeroes = '00000000000';\nvar fiftyOneZeroes = elevenZeroes + elevenZeroes + elevenZeroes + elevenZeroes + '0000000';\n\n// IEEE 754-1985\nmodule.exports = function valueToFloat64Bytes(value, isLittleEndian) {\n  var signBit = value < 0 || isNegativeZero(value) ? '1' : '0';\n  var exponentBits;\n  var significandBits;\n  if (isNaN(value)) {\n    exponentBits = elevenOnes;\n    significandBits = '1' + fiftyOneZeroes;\n  } else if (!isFinite(value)) {\n    exponentBits = elevenOnes;\n    significandBits = '0' + fiftyOneZeroes;\n  } else if (value === 0) {\n    exponentBits = elevenZeroes;\n    significandBits = '0' + fiftyOneZeroes;\n  } else {\n    value = $abs(value); // eslint-disable-line no-param-reassign\n\n    // Isolate the integer part (digits before the decimal):\n    var integerPart = $floor(value);\n    var intBinString = intToBinString(integerPart); // bit string for integer part\n    var fracBinString = fractionToBitString(value - integerPart); // bit string for fractional part\n\n    var numberOfBits;\n    // find exponent needed to normalize integer+fractional parts\n    if (intBinString) {\n      exponentBits = intBinString.length - 1; // move the decimal to the left\n    } else {\n      var first1 = $strIndexOf(fracBinString, '1');\n      if (first1 > -1) {\n        numberOfBits = first1 + 1;\n      }\n      exponentBits = -numberOfBits; // move the decimal to the right\n    }\n    significandBits = intBinString + fracBinString;\n    if (exponentBits < 0) {\n      // subnormals\n      if (exponentBits <= -float64bias) {\n        numberOfBits = float64bias - 1; // limit number of removed bits\n      }\n      significandBits = $strSlice(significandBits, numberOfBits); // remove all leading 0s and the first 1 for normal values; for subnormals, remove up to `float64bias - 1` leading bits\n    } else {\n      significandBits = $strSlice(significandBits, 1); // remove the leading '1' (implicit/hidden bit)\n    }\n    exponentBits = $strSlice(elevenZeroes + intToBinString(exponentBits + float64bias), -11); // Convert the exponent to a bit string\n\n    significandBits = $strSlice(significandBits + fiftyOneZeroes + '0', 0, 52); // fill in any trailing zeros and ensure we have only 52 fraction bits\n  }\n  var bits = signBit + exponentBits + significandBits;\n  var rawBytes = [];\n  for (var i = 0; i < 8; i++) {\n    var targetIndex = isLittleEndian ? 8 - i - 1 : i;\n    rawBytes[targetIndex] = $parseInt($strSlice(bits, i * 8, (i + 1) * 8), 2);\n  }\n  return rawBytes;\n};","map":{"version":3,"names":["GetIntrinsic","require","$parseInt","$abs","$floor","isNegativeZero","callBound","$strIndexOf","$strSlice","fractionToBitString","intToBinString","float64bias","elevenOnes","elevenZeroes","fiftyOneZeroes","module","exports","valueToFloat64Bytes","value","isLittleEndian","signBit","exponentBits","significandBits","isNaN","isFinite","integerPart","intBinString","fracBinString","numberOfBits","length","first1","bits","rawBytes","i","targetIndex"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/es-abstract/helpers/valueToFloat64Bytes.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $parseInt = GetIntrinsic('%parseInt%');\nvar $abs = require('math-intrinsics/abs');\nvar $floor = require('math-intrinsics/floor');\nvar isNegativeZero = require('math-intrinsics/isNegativeZero');\n\nvar callBound = require('call-bound');\n\nvar $strIndexOf = callBound('String.prototype.indexOf');\nvar $strSlice = callBound('String.prototype.slice');\n\nvar fractionToBitString = require('../helpers/fractionToBinaryString');\nvar intToBinString = require('../helpers/intToBinaryString');\n\nvar float64bias = 1023;\n\nvar elevenOnes = '11111111111';\nvar elevenZeroes = '00000000000';\nvar fiftyOneZeroes = elevenZeroes + elevenZeroes + elevenZeroes + elevenZeroes + '0000000';\n\n// IEEE 754-1985\nmodule.exports = function valueToFloat64Bytes(value, isLittleEndian) {\n\tvar signBit = value < 0 || isNegativeZero(value) ? '1' : '0';\n\tvar exponentBits;\n\tvar significandBits;\n\n\tif (isNaN(value)) {\n\t\texponentBits = elevenOnes;\n\t\tsignificandBits = '1' + fiftyOneZeroes;\n\t} else if (!isFinite(value)) {\n\t\texponentBits = elevenOnes;\n\t\tsignificandBits = '0' + fiftyOneZeroes;\n\t} else if (value === 0) {\n\t\texponentBits = elevenZeroes;\n\t\tsignificandBits = '0' + fiftyOneZeroes;\n\t} else {\n\t\tvalue = $abs(value); // eslint-disable-line no-param-reassign\n\n\t\t// Isolate the integer part (digits before the decimal):\n\t\tvar integerPart = $floor(value);\n\n\t\tvar intBinString = intToBinString(integerPart); // bit string for integer part\n\t\tvar fracBinString = fractionToBitString(value - integerPart); // bit string for fractional part\n\n\t\tvar numberOfBits;\n\t\t// find exponent needed to normalize integer+fractional parts\n\t\tif (intBinString) {\n\t\t\texponentBits = intBinString.length - 1; // move the decimal to the left\n\t\t} else {\n\t\t\tvar first1 = $strIndexOf(fracBinString, '1');\n\t\t\tif (first1 > -1) {\n\t\t\t\tnumberOfBits = first1 + 1;\n\t\t\t}\n\t\t\texponentBits = -numberOfBits; // move the decimal to the right\n\t\t}\n\n\t\tsignificandBits = intBinString + fracBinString;\n\t\tif (exponentBits < 0) {\n\t\t\t// subnormals\n\t\t\tif (exponentBits <= -float64bias) {\n\t\t\t\tnumberOfBits = float64bias - 1; // limit number of removed bits\n\t\t\t}\n\t\t\tsignificandBits = $strSlice(significandBits, numberOfBits); // remove all leading 0s and the first 1 for normal values; for subnormals, remove up to `float64bias - 1` leading bits\n\t\t} else {\n\t\t\tsignificandBits = $strSlice(significandBits, 1); // remove the leading '1' (implicit/hidden bit)\n\t\t}\n\t\texponentBits = $strSlice(elevenZeroes + intToBinString(exponentBits + float64bias), -11); // Convert the exponent to a bit string\n\n\t\tsignificandBits = $strSlice(significandBits + fiftyOneZeroes + '0', 0, 52); // fill in any trailing zeros and ensure we have only 52 fraction bits\n\t}\n\n\tvar bits = signBit + exponentBits + significandBits;\n\tvar rawBytes = [];\n\tfor (var i = 0; i < 8; i++) {\n\t\tvar targetIndex = isLittleEndian ? 8 - i - 1 : i;\n\t\trawBytes[targetIndex] = $parseInt($strSlice(bits, i * 8, (i + 1) * 8), 2);\n\t}\n\n\treturn rawBytes;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAE3C,IAAIC,SAAS,GAAGF,YAAY,CAAC,YAAY,CAAC;AAC1C,IAAIG,IAAI,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AACzC,IAAIG,MAAM,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AAC7C,IAAII,cAAc,GAAGJ,OAAO,CAAC,gCAAgC,CAAC;AAE9D,IAAIK,SAAS,GAAGL,OAAO,CAAC,YAAY,CAAC;AAErC,IAAIM,WAAW,GAAGD,SAAS,CAAC,0BAA0B,CAAC;AACvD,IAAIE,SAAS,GAAGF,SAAS,CAAC,wBAAwB,CAAC;AAEnD,IAAIG,mBAAmB,GAAGR,OAAO,CAAC,mCAAmC,CAAC;AACtE,IAAIS,cAAc,GAAGT,OAAO,CAAC,8BAA8B,CAAC;AAE5D,IAAIU,WAAW,GAAG,IAAI;AAEtB,IAAIC,UAAU,GAAG,aAAa;AAC9B,IAAIC,YAAY,GAAG,aAAa;AAChC,IAAIC,cAAc,GAAGD,YAAY,GAAGA,YAAY,GAAGA,YAAY,GAAGA,YAAY,GAAG,SAAS;;AAE1F;AACAE,MAAM,CAACC,OAAO,GAAG,SAASC,mBAAmBA,CAACC,KAAK,EAAEC,cAAc,EAAE;EACpE,IAAIC,OAAO,GAAGF,KAAK,GAAG,CAAC,IAAIb,cAAc,CAACa,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG;EAC5D,IAAIG,YAAY;EAChB,IAAIC,eAAe;EAEnB,IAAIC,KAAK,CAACL,KAAK,CAAC,EAAE;IACjBG,YAAY,GAAGT,UAAU;IACzBU,eAAe,GAAG,GAAG,GAAGR,cAAc;EACvC,CAAC,MAAM,IAAI,CAACU,QAAQ,CAACN,KAAK,CAAC,EAAE;IAC5BG,YAAY,GAAGT,UAAU;IACzBU,eAAe,GAAG,GAAG,GAAGR,cAAc;EACvC,CAAC,MAAM,IAAII,KAAK,KAAK,CAAC,EAAE;IACvBG,YAAY,GAAGR,YAAY;IAC3BS,eAAe,GAAG,GAAG,GAAGR,cAAc;EACvC,CAAC,MAAM;IACNI,KAAK,GAAGf,IAAI,CAACe,KAAK,CAAC,CAAC,CAAC;;IAErB;IACA,IAAIO,WAAW,GAAGrB,MAAM,CAACc,KAAK,CAAC;IAE/B,IAAIQ,YAAY,GAAGhB,cAAc,CAACe,WAAW,CAAC,CAAC,CAAC;IAChD,IAAIE,aAAa,GAAGlB,mBAAmB,CAACS,KAAK,GAAGO,WAAW,CAAC,CAAC,CAAC;;IAE9D,IAAIG,YAAY;IAChB;IACA,IAAIF,YAAY,EAAE;MACjBL,YAAY,GAAGK,YAAY,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC,MAAM;MACN,IAAIC,MAAM,GAAGvB,WAAW,CAACoB,aAAa,EAAE,GAAG,CAAC;MAC5C,IAAIG,MAAM,GAAG,CAAC,CAAC,EAAE;QAChBF,YAAY,GAAGE,MAAM,GAAG,CAAC;MAC1B;MACAT,YAAY,GAAG,CAACO,YAAY,CAAC,CAAC;IAC/B;IAEAN,eAAe,GAAGI,YAAY,GAAGC,aAAa;IAC9C,IAAIN,YAAY,GAAG,CAAC,EAAE;MACrB;MACA,IAAIA,YAAY,IAAI,CAACV,WAAW,EAAE;QACjCiB,YAAY,GAAGjB,WAAW,GAAG,CAAC,CAAC,CAAC;MACjC;MACAW,eAAe,GAAGd,SAAS,CAACc,eAAe,EAAEM,YAAY,CAAC,CAAC,CAAC;IAC7D,CAAC,MAAM;MACNN,eAAe,GAAGd,SAAS,CAACc,eAAe,EAAE,CAAC,CAAC,CAAC,CAAC;IAClD;IACAD,YAAY,GAAGb,SAAS,CAACK,YAAY,GAAGH,cAAc,CAACW,YAAY,GAAGV,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;IAE1FW,eAAe,GAAGd,SAAS,CAACc,eAAe,GAAGR,cAAc,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7E;EAEA,IAAIiB,IAAI,GAAGX,OAAO,GAAGC,YAAY,GAAGC,eAAe;EACnD,IAAIU,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC3B,IAAIC,WAAW,GAAGf,cAAc,GAAG,CAAC,GAAGc,CAAC,GAAG,CAAC,GAAGA,CAAC;IAChDD,QAAQ,CAACE,WAAW,CAAC,GAAGhC,SAAS,CAACM,SAAS,CAACuB,IAAI,EAAEE,CAAC,GAAG,CAAC,EAAE,CAACA,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1E;EAEA,OAAOD,QAAQ;AAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}