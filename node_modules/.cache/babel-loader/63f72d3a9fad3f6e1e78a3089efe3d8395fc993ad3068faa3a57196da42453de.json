{"ast":null,"code":"var wgs84 = require('wgs84');\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\nfunction geometry(_) {\n  var area = 0,\n    i;\n  switch (_.type) {\n    case 'Polygon':\n      return polygonArea(_.coordinates);\n    case 'MultiPolygon':\n      for (i = 0; i < _.coordinates.length; i++) {\n        area += polygonArea(_.coordinates[i]);\n      }\n      return area;\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n      return 0;\n    case 'GeometryCollection':\n      for (i = 0; i < _.geometries.length; i++) {\n        area += geometry(_.geometries[i]);\n      }\n      return area;\n  }\n}\nfunction polygonArea(coords) {\n  var area = 0;\n  if (coords && coords.length > 0) {\n    area += Math.abs(ringArea(coords[0]));\n    for (var i = 1; i < coords.length; i++) {\n      area -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n  var p1,\n    p2,\n    p3,\n    lowerIndex,\n    middleIndex,\n    upperIndex,\n    i,\n    area = 0,\n    coordsLength = coords.length;\n  if (coordsLength > 2) {\n    for (i = 0; i < coordsLength; i++) {\n      if (i === coordsLength - 2) {\n        // i = N-2\n        lowerIndex = coordsLength - 2;\n        middleIndex = coordsLength - 1;\n        upperIndex = 0;\n      } else if (i === coordsLength - 1) {\n        // i = N-1\n        lowerIndex = coordsLength - 1;\n        middleIndex = 0;\n        upperIndex = 1;\n      } else {\n        // i = 0 to N-3\n        lowerIndex = i;\n        middleIndex = i + 1;\n        upperIndex = i + 2;\n      }\n      p1 = coords[lowerIndex];\n      p2 = coords[middleIndex];\n      p3 = coords[upperIndex];\n      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n    }\n    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n  }\n  return area;\n}\nfunction rad(_) {\n  return _ * Math.PI / 180;\n}","map":{"version":3,"names":["wgs84","require","module","exports","geometry","ring","ringArea","_","area","i","type","polygonArea","coordinates","length","geometries","coords","Math","abs","p1","p2","p3","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","PI"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@mapbox/geojson-area/index.js"],"sourcesContent":["var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}