{"ast":null,"code":"\"use strict\";\n\nvar contextUtils = require('../context_utils');\nvar mwUtils = require('../middleware/mw_utils');\nvar LambdaUtils = require('../utils').LambdaUtils;\nvar Segment = require('../segments/segment');\nvar SegmentEmitter = require('../segment_emitter');\nvar SegmentUtils = require('../segments/segment_utils');\nvar logger = require('../logger');\nconst TraceID = require('../segments/attributes/trace_id');\n/**\n * @namespace\n * @ignore\n */\nvar xAmznTraceIdPrev = null;\n/**\n* Used to initialize segments on AWS Lambda with extra data from the context.\n*/\nmodule.exports.init = function init() {\n  contextUtils.enableManualMode = function () {\n    logger.getLogger().warn('AWS Lambda does not support AWS X-Ray manual mode.');\n  };\n  SegmentEmitter.disableReusableSocket();\n  SegmentUtils.setStreamingThreshold(0);\n  /**\n   * Disabling all centralized sampling in Lambda environments. The sampling decisions would be\n   * uselessly applied to the facade segment, and the sampling pollers were causing errors.\n   *\n   * See: https://github.com/aws/aws-xray-sdk-node/issues/217\n   */\n  logger.getLogger().info('Disabling centralized sampling in Lambda environment.');\n  mwUtils.disableCentralizedSampling();\n  var namespace = contextUtils.getNamespace();\n  namespace.enter(namespace.createContext());\n  contextUtils.setSegment(facadeSegment());\n};\nvar facadeSegment = function facadeSegment() {\n  var segment = new Segment('facade');\n  var whitelistFcn = ['addNewSubsegment', 'addSubsegment', 'removeSubsegment', 'toString', 'addSubsegmentWithoutSampling', 'addNewSubsegmentWithoutSampling'];\n  var silentFcn = ['incrementCounter', 'decrementCounter', 'isClosed', 'close', 'format', 'flush'];\n  var xAmznTraceId = process.env._X_AMZN_TRACE_ID;\n  for (var key in segment) {\n    if (typeof segment[key] === 'function' && whitelistFcn.indexOf(key) === -1) {\n      if (silentFcn.indexOf(key) === -1) {\n        segment[key] = function () {\n          var func = key;\n          return function facade() {\n            logger.getLogger().warn('Function \"' + func + '\" cannot be called on an AWS Lambda segment. Please use a subsegment to record data.');\n            return;\n          };\n        }();\n      } else {\n        segment[key] = function facade() {\n          return;\n        };\n      }\n    }\n  }\n  segment.trace_id = TraceID.Invalid().toString();\n  segment.isClosed = function () {\n    return true;\n  };\n  segment.in_progress = false;\n  segment.counter = 1;\n  segment.notTraced = true;\n  segment.facade = true;\n  segment.reset = function reset() {\n    this.trace_id = TraceID.Invalid().toString();\n    this.id = '00000000';\n    delete this.subsegments;\n    this.notTraced = true;\n  };\n  segment.resolveLambdaTraceData = function resolveLambdaTraceData() {\n    var xAmznLambda = process.env._X_AMZN_TRACE_ID;\n    if (xAmznLambda) {\n      // This check resets the trace data whenever a new trace header is read to not leak data between invocations\n      if (xAmznLambda != xAmznTraceIdPrev) {\n        this.reset();\n        if (LambdaUtils.populateTraceData(segment, xAmznLambda)) {\n          xAmznTraceIdPrev = xAmznLambda;\n        }\n      }\n    } else {\n      this.reset();\n      contextUtils.contextMissingStrategy.contextMissing('Missing AWS Lambda trace data for X-Ray. ' + 'Ensure Active Tracing is enabled and no subsegments are created outside the function handler.');\n    }\n  };\n  // Test for valid trace data during SDK startup. It's likely we're still in the cold-start portion of the\n  // code at this point and a valid trace header has not been set\n  if (LambdaUtils.validTraceData(xAmznTraceId)) {\n    if (LambdaUtils.populateTraceData(segment, xAmznTraceId)) {\n      xAmznTraceIdPrev = xAmznTraceId;\n    }\n  }\n  return segment;\n};","map":{"version":3,"names":["contextUtils","require","mwUtils","LambdaUtils","Segment","SegmentEmitter","SegmentUtils","logger","TraceID","xAmznTraceIdPrev","module","exports","init","enableManualMode","getLogger","warn","disableReusableSocket","setStreamingThreshold","info","disableCentralizedSampling","namespace","getNamespace","enter","createContext","setSegment","facadeSegment","segment","whitelistFcn","silentFcn","xAmznTraceId","process","env","_X_AMZN_TRACE_ID","key","indexOf","func","facade","trace_id","Invalid","toString","isClosed","in_progress","counter","notTraced","reset","id","subsegments","resolveLambdaTraceData","xAmznLambda","populateTraceData","contextMissingStrategy","contextMissing","validTraceData"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/env/aws_lambda.js"],"sourcesContent":["\"use strict\";\nvar contextUtils = require('../context_utils');\nvar mwUtils = require('../middleware/mw_utils');\nvar LambdaUtils = require('../utils').LambdaUtils;\nvar Segment = require('../segments/segment');\nvar SegmentEmitter = require('../segment_emitter');\nvar SegmentUtils = require('../segments/segment_utils');\nvar logger = require('../logger');\nconst TraceID = require('../segments/attributes/trace_id');\n/**\n * @namespace\n * @ignore\n */\nvar xAmznTraceIdPrev = null;\n/**\n* Used to initialize segments on AWS Lambda with extra data from the context.\n*/\nmodule.exports.init = function init() {\n    contextUtils.enableManualMode = function () {\n        logger.getLogger().warn('AWS Lambda does not support AWS X-Ray manual mode.');\n    };\n    SegmentEmitter.disableReusableSocket();\n    SegmentUtils.setStreamingThreshold(0);\n    /**\n     * Disabling all centralized sampling in Lambda environments. The sampling decisions would be\n     * uselessly applied to the facade segment, and the sampling pollers were causing errors.\n     *\n     * See: https://github.com/aws/aws-xray-sdk-node/issues/217\n     */\n    logger.getLogger().info('Disabling centralized sampling in Lambda environment.');\n    mwUtils.disableCentralizedSampling();\n    var namespace = contextUtils.getNamespace();\n    namespace.enter(namespace.createContext());\n    contextUtils.setSegment(facadeSegment());\n};\nvar facadeSegment = function facadeSegment() {\n    var segment = new Segment('facade');\n    var whitelistFcn = ['addNewSubsegment', 'addSubsegment', 'removeSubsegment', 'toString', 'addSubsegmentWithoutSampling', 'addNewSubsegmentWithoutSampling'];\n    var silentFcn = ['incrementCounter', 'decrementCounter', 'isClosed', 'close', 'format', 'flush'];\n    var xAmznTraceId = process.env._X_AMZN_TRACE_ID;\n    for (var key in segment) {\n        if (typeof segment[key] === 'function' && whitelistFcn.indexOf(key) === -1) {\n            if (silentFcn.indexOf(key) === -1) {\n                segment[key] = (function () {\n                    var func = key;\n                    return function facade() {\n                        logger.getLogger().warn('Function \"' + func + '\" cannot be called on an AWS Lambda segment. Please use a subsegment to record data.');\n                        return;\n                    };\n                })();\n            }\n            else {\n                segment[key] = function facade() {\n                    return;\n                };\n            }\n        }\n    }\n    segment.trace_id = TraceID.Invalid().toString();\n    segment.isClosed = function () {\n        return true;\n    };\n    segment.in_progress = false;\n    segment.counter = 1;\n    segment.notTraced = true;\n    segment.facade = true;\n    segment.reset = function reset() {\n        this.trace_id = TraceID.Invalid().toString();\n        this.id = '00000000';\n        delete this.subsegments;\n        this.notTraced = true;\n    };\n    segment.resolveLambdaTraceData = function resolveLambdaTraceData() {\n        var xAmznLambda = process.env._X_AMZN_TRACE_ID;\n        if (xAmznLambda) {\n            // This check resets the trace data whenever a new trace header is read to not leak data between invocations\n            if (xAmznLambda != xAmznTraceIdPrev) {\n                this.reset();\n                if (LambdaUtils.populateTraceData(segment, xAmznLambda)) {\n                    xAmznTraceIdPrev = xAmznLambda;\n                }\n            }\n        }\n        else {\n            this.reset();\n            contextUtils.contextMissingStrategy.contextMissing('Missing AWS Lambda trace data for X-Ray. ' +\n                'Ensure Active Tracing is enabled and no subsegments are created outside the function handler.');\n        }\n    };\n    // Test for valid trace data during SDK startup. It's likely we're still in the cold-start portion of the\n    // code at this point and a valid trace header has not been set\n    if (LambdaUtils.validTraceData(xAmznTraceId)) {\n        if (LambdaUtils.populateTraceData(segment, xAmznTraceId)) {\n            xAmznTraceIdPrev = xAmznTraceId;\n        }\n    }\n    return segment;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}