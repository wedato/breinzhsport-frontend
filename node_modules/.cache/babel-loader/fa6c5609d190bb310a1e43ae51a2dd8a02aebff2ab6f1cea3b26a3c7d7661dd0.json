{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __extends } from \"tslib\";\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { defaultConfig, getCurrTime } from './Utils';\nimport { StorageCache } from './StorageCache';\nvar logger = new Logger('Cache');\n/**\n * Customized storage based on the SessionStorage or LocalStorage with LRU implemented\n */\nvar BrowserStorageCacheClass = /** @class */function (_super) {\n  __extends(BrowserStorageCacheClass, _super);\n  /**\n   * initialize the cache\n   * @param config - the configuration of the cache\n   */\n  function BrowserStorageCacheClass(config) {\n    var _this = this;\n    var cacheConfig = config ? Object.assign({}, defaultConfig, config) : defaultConfig;\n    _this = _super.call(this, cacheConfig) || this;\n    _this.config.storage = cacheConfig.storage;\n    _this.getItem = _this.getItem.bind(_this);\n    _this.setItem = _this.setItem.bind(_this);\n    _this.removeItem = _this.removeItem.bind(_this);\n    return _this;\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @private\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  BrowserStorageCacheClass.prototype._decreaseCurSizeInBytes = function (amount) {\n    var curSize = this.getCacheCurSize();\n    this.config.storage.setItem(this.cacheCurSizeKey, (curSize - amount).toString());\n  };\n  /**\n   * increase current size of the cache\n   *\n   * @private\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  BrowserStorageCacheClass.prototype._increaseCurSizeInBytes = function (amount) {\n    var curSize = this.getCacheCurSize();\n    this.config.storage.setItem(this.cacheCurSizeKey, (curSize + amount).toString());\n  };\n  /**\n   * update the visited time if item has been visited\n   *\n   * @private\n   * @param item - the item which need to be refreshed\n   * @param prefixedKey - the key of the item\n   *\n   * @return the refreshed item\n   */\n  BrowserStorageCacheClass.prototype._refreshItem = function (item, prefixedKey) {\n    item.visitedTime = getCurrTime();\n    this.config.storage.setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  };\n  /**\n   * check wether item is expired\n   *\n   * @private\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  BrowserStorageCacheClass.prototype._isExpired = function (key) {\n    var text = this.config.storage.getItem(key);\n    var item = JSON.parse(text);\n    if (getCurrTime() >= item.expires) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * delete item from cache\n   *\n   * @private\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  BrowserStorageCacheClass.prototype._removeItem = function (prefixedKey, size) {\n    var itemSize = size ? size : JSON.parse(this.config.storage.getItem(prefixedKey)).byteSize;\n    this._decreaseCurSizeInBytes(itemSize);\n    // remove the cache item\n    this.config.storage.removeItem(prefixedKey);\n  };\n  /**\n   * put item into cache\n   *\n   * @private\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  BrowserStorageCacheClass.prototype._setItem = function (prefixedKey, item) {\n    // update the cache size\n    this._increaseCurSizeInBytes(item.byteSize);\n    try {\n      this.config.storage.setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if failed, we need to rollback the cache size\n      this._decreaseCurSizeInBytes(item.byteSize);\n      logger.error(\"Failed to set item \" + setItemErr);\n    }\n  };\n  /**\n   * total space needed when poping out items\n   *\n   * @private\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  BrowserStorageCacheClass.prototype._sizeToPop = function (itemSize) {\n    var spaceItemNeed = this.getCacheCurSize() + itemSize - this.config.capacityInBytes;\n    var cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  };\n  /**\n   * see whether cache is full\n   *\n   * @private\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  BrowserStorageCacheClass.prototype._isCacheFull = function (itemSize) {\n    return itemSize + this.getCacheCurSize() > this.config.capacityInBytes;\n  };\n  /**\n   * scan the storage and find out all the keys owned by this cache\n   * also clean the expired keys while scanning\n   *\n   * @private\n   *\n   * @return array of keys\n   */\n  BrowserStorageCacheClass.prototype._findValidKeys = function () {\n    var keys = [];\n    var keyInCache = [];\n    // get all keys in Storage\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      keyInCache.push(this.config.storage.key(i));\n    }\n    // find those items which belong to our cache and also clean those expired items\n    for (var i = 0; i < keyInCache.length; i += 1) {\n      var key = keyInCache[i];\n      if (key.indexOf(this.config.keyPrefix) === 0 && key !== this.cacheCurSizeKey) {\n        if (this._isExpired(key)) {\n          this._removeItem(key);\n        } else {\n          keys.push(key);\n        }\n      }\n    }\n    return keys;\n  };\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   *\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  BrowserStorageCacheClass.prototype._popOutItems = function (keys, sizeToPop) {\n    var items = [];\n    var remainedSize = sizeToPop;\n    // get the items from Storage\n    for (var i = 0; i < keys.length; i += 1) {\n      var val = this.config.storage.getItem(keys[i]);\n      if (val != null) {\n        var item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort(function (a, b) {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (var i = 0; i < items.length; i += 1) {\n      // pop out items until we have enough room for new item\n      this._removeItem(items[i].key, items[i].byteSize);\n      remainedSize -= items[i].byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  };\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param key - the key of the item\n   * @param value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   */\n  BrowserStorageCacheClass.prototype.setItem = function (key, value, options) {\n    logger.log(\"Set item: key is \" + key + \", value is \" + value + \" with options: \" + options);\n    var prefixedKey = this.config.keyPrefix + key;\n    // invalid keys\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or 'CurSize'\");\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(\"The value of item should not be undefined!\");\n      return;\n    }\n    var cacheItemOptions = {\n      priority: options && options.priority !== undefined ? options.priority : this.config.defaultPriority,\n      expires: options && options.expires !== undefined ? options.expires : this.config.defaultTTL + getCurrTime()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(\"Invalid parameter: priority due to out or range. It should be within 1 and 5.\");\n      return;\n    }\n    var item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check wether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(\"Item with key: \" + key + \" you are trying to put into is too big!\");\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      var val = this.config.storage.getItem(prefixedKey);\n      if (val) {\n        this._removeItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (this._isCacheFull(item.byteSize)) {\n        var validKeys = this._findValidKeys();\n        // check again and then pop out items\n        if (this._isCacheFull(item.byteSize)) {\n          var sizeToPop = this._sizeToPop(item.byteSize);\n          this._popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      // may failed due to storage full\n      this._setItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(\"setItem failed! \" + e);\n    }\n  };\n  /**\n   * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with browser storage\n   *\n   * @param key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return - return the value of the item\n   */\n  BrowserStorageCacheClass.prototype.getItem = function (key, options) {\n    logger.log(\"Get item: key is \" + key + \" with options \" + options);\n    var ret = null;\n    var prefixedKey = this.config.keyPrefix + key;\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or 'CurSize'\");\n      return null;\n    }\n    try {\n      ret = this.config.storage.getItem(prefixedKey);\n      if (ret != null) {\n        if (this._isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          this._removeItem(prefixedKey, JSON.parse(ret).byteSize);\n          ret = null;\n        } else {\n          // if not expired, great, return the value and refresh it\n          var item = JSON.parse(ret);\n          item = this._refreshItem(item, prefixedKey);\n          return item.data;\n        }\n      }\n      if (options && options.callback !== undefined) {\n        var val = options.callback();\n        if (val !== null) {\n          this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(\"getItem failed! \" + e);\n      return null;\n    }\n  };\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with browser storage\n   * @param key - the key of the item\n   */\n  BrowserStorageCacheClass.prototype.removeItem = function (key) {\n    logger.log(\"Remove item: key is \" + key);\n    var prefixedKey = this.config.keyPrefix + key;\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      return;\n    }\n    try {\n      var val = this.config.storage.getItem(prefixedKey);\n      if (val) {\n        this._removeItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(\"removeItem failed! \" + e);\n    }\n  };\n  /**\n   * clear the entire cache\n   * The cache will abort output a warning:\n   * If error happened with browser storage\n   */\n  BrowserStorageCacheClass.prototype.clear = function () {\n    logger.log(\"Clear Cache\");\n    var keysToRemove = [];\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      var key = this.config.storage.key(i);\n      if (key.indexOf(this.config.keyPrefix) === 0) {\n        keysToRemove.push(key);\n      }\n    }\n    try {\n      for (var i = 0; i < keysToRemove.length; i += 1) {\n        this.config.storage.removeItem(keysToRemove[i]);\n      }\n    } catch (e) {\n      logger.warn(\"clear failed! \" + e);\n    }\n  };\n  /**\n   * Return all the keys in the cache.\n   *\n   * @return - all keys in the cache\n   */\n  BrowserStorageCacheClass.prototype.getAllKeys = function () {\n    var keys = [];\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      var key = this.config.storage.key(i);\n      if (key.indexOf(this.config.keyPrefix) === 0 && key !== this.cacheCurSizeKey) {\n        keys.push(key.substring(this.config.keyPrefix.length));\n      }\n    }\n    return keys;\n  };\n  /**\n   * return the current size of the cache\n   *\n   * @return - current size of the cache\n   */\n  BrowserStorageCacheClass.prototype.getCacheCurSize = function () {\n    var ret = this.config.storage.getItem(this.cacheCurSizeKey);\n    if (!ret) {\n      this.config.storage.setItem(this.cacheCurSizeKey, '0');\n      ret = '0';\n    }\n    return Number(ret);\n  };\n  /**\n   * Return a new instance of cache with customized configuration.\n   * @param config - the customized configuration\n   *\n   * @return - new instance of Cache\n   */\n  BrowserStorageCacheClass.prototype.createInstance = function (config) {\n    if (!config.keyPrefix || config.keyPrefix === defaultConfig.keyPrefix) {\n      logger.error('invalid keyPrefix, setting keyPrefix with timeStamp');\n      config.keyPrefix = getCurrTime.toString();\n    }\n    return new BrowserStorageCacheClass(config);\n  };\n  return BrowserStorageCacheClass;\n}(StorageCache);\nexport { BrowserStorageCacheClass };\nexport var BrowserStorageCache = new BrowserStorageCacheClass();\nAmplify.register(BrowserStorageCache);","map":{"version":3,"names":["Amplify","ConsoleLogger","Logger","defaultConfig","getCurrTime","StorageCache","logger","BrowserStorageCacheClass","_super","__extends","config","_this","cacheConfig","Object","assign","call","storage","getItem","bind","setItem","removeItem","prototype","_decreaseCurSizeInBytes","amount","curSize","getCacheCurSize","cacheCurSizeKey","toString","_increaseCurSizeInBytes","_refreshItem","item","prefixedKey","visitedTime","JSON","stringify","_isExpired","key","text","parse","expires","_removeItem","size","itemSize","byteSize","_setItem","setItemErr","error","_sizeToPop","spaceItemNeed","capacityInBytes","cacheThresholdSpace","warningThreshold","_isCacheFull","_findValidKeys","keys","keyInCache","i","length","push","indexOf","keyPrefix","_popOutItems","sizeToPop","items","remainedSize","val","sort","a","b","priority","value","options","log","warn","cacheItemOptions","undefined","defaultPriority","defaultTTL","fillCacheItem","itemMaxSize","validKeys","e","ret","data","callback","clear","keysToRemove","getAllKeys","substring","Number","createInstance","BrowserStorageCache","register"],"sources":["C:\\Users\\jonat\\aws_poc\\frontend\\node_modules\\@aws-amplify\\cache\\src\\BrowserStorageCache.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\r\nimport { defaultConfig, getCurrTime } from './Utils';\r\nimport { StorageCache } from './StorageCache';\r\nimport { ICache, CacheConfig, CacheItem, CacheItemOptions } from './types';\r\n\r\nconst logger = new Logger('Cache');\r\n\r\n/**\r\n * Customized storage based on the SessionStorage or LocalStorage with LRU implemented\r\n */\r\nexport class BrowserStorageCacheClass extends StorageCache implements ICache {\r\n\t/**\r\n\t * initialize the cache\r\n\t * @param config - the configuration of the cache\r\n\t */\r\n\tconstructor(config?: CacheConfig) {\r\n\t\tconst cacheConfig = config\r\n\t\t\t? Object.assign({}, defaultConfig, config)\r\n\t\t\t: defaultConfig;\r\n\t\tsuper(cacheConfig);\r\n\t\tthis.config.storage = cacheConfig.storage;\r\n\t\tthis.getItem = this.getItem.bind(this);\r\n\t\tthis.setItem = this.setItem.bind(this);\r\n\t\tthis.removeItem = this.removeItem.bind(this);\r\n\t}\r\n\r\n\t/**\r\n\t * decrease current size of the cache\r\n\t *\r\n\t * @private\r\n\t * @param amount - the amount of the cache size which needs to be decreased\r\n\t */\r\n\tprivate _decreaseCurSizeInBytes(amount: number): void {\r\n\t\tconst curSize: number = this.getCacheCurSize();\r\n\t\tthis.config.storage.setItem(\r\n\t\t\tthis.cacheCurSizeKey,\r\n\t\t\t(curSize - amount).toString()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * increase current size of the cache\r\n\t *\r\n\t * @private\r\n\t * @param amount - the amount of the cache szie which need to be increased\r\n\t */\r\n\tprivate _increaseCurSizeInBytes(amount: number): void {\r\n\t\tconst curSize: number = this.getCacheCurSize();\r\n\t\tthis.config.storage.setItem(\r\n\t\t\tthis.cacheCurSizeKey,\r\n\t\t\t(curSize + amount).toString()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * update the visited time if item has been visited\r\n\t *\r\n\t * @private\r\n\t * @param item - the item which need to be refreshed\r\n\t * @param prefixedKey - the key of the item\r\n\t *\r\n\t * @return the refreshed item\r\n\t */\r\n\tprivate _refreshItem(item: CacheItem, prefixedKey: string): CacheItem {\r\n\t\titem.visitedTime = getCurrTime();\r\n\t\tthis.config.storage.setItem(prefixedKey, JSON.stringify(item));\r\n\t\treturn item;\r\n\t}\r\n\r\n\t/**\r\n\t * check wether item is expired\r\n\t *\r\n\t * @private\r\n\t * @param key - the key of the item\r\n\t *\r\n\t * @return true if the item is expired.\r\n\t */\r\n\tprivate _isExpired(key: string): boolean {\r\n\t\tconst text: string | null = this.config.storage.getItem(key);\r\n\t\tconst item: CacheItem = JSON.parse(text);\r\n\t\tif (getCurrTime() >= item.expires) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * delete item from cache\r\n\t *\r\n\t * @private\r\n\t * @param prefixedKey - the key of the item\r\n\t * @param size - optional, the byte size of the item\r\n\t */\r\n\tprivate _removeItem(prefixedKey: string, size?: number): void {\r\n\t\tconst itemSize: number = size\r\n\t\t\t? size\r\n\t\t\t: JSON.parse(this.config.storage.getItem(prefixedKey)).byteSize;\r\n\t\tthis._decreaseCurSizeInBytes(itemSize);\r\n\t\t// remove the cache item\r\n\t\tthis.config.storage.removeItem(prefixedKey);\r\n\t}\r\n\r\n\t/**\r\n\t * put item into cache\r\n\t *\r\n\t * @private\r\n\t * @param prefixedKey - the key of the item\r\n\t * @param itemData - the value of the item\r\n\t * @param itemSizeInBytes - the byte size of the item\r\n\t */\r\n\tprivate _setItem(prefixedKey: string, item: CacheItem): void {\r\n\t\t// update the cache size\r\n\t\tthis._increaseCurSizeInBytes(item.byteSize);\r\n\r\n\t\ttry {\r\n\t\t\tthis.config.storage.setItem(prefixedKey, JSON.stringify(item));\r\n\t\t} catch (setItemErr) {\r\n\t\t\t// if failed, we need to rollback the cache size\r\n\t\t\tthis._decreaseCurSizeInBytes(item.byteSize);\r\n\t\t\tlogger.error(`Failed to set item ${setItemErr}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * total space needed when poping out items\r\n\t *\r\n\t * @private\r\n\t * @param itemSize\r\n\t *\r\n\t * @return total space needed\r\n\t */\r\n\tprivate _sizeToPop(itemSize: number): number {\r\n\t\tconst spaceItemNeed =\r\n\t\t\tthis.getCacheCurSize() + itemSize - this.config.capacityInBytes;\r\n\t\tconst cacheThresholdSpace =\r\n\t\t\t(1 - this.config.warningThreshold) * this.config.capacityInBytes;\r\n\t\treturn spaceItemNeed > cacheThresholdSpace\r\n\t\t\t? spaceItemNeed\r\n\t\t\t: cacheThresholdSpace;\r\n\t}\r\n\r\n\t/**\r\n\t * see whether cache is full\r\n\t *\r\n\t * @private\r\n\t * @param itemSize\r\n\t *\r\n\t * @return true if cache is full\r\n\t */\r\n\tprivate _isCacheFull(itemSize: number): boolean {\r\n\t\treturn itemSize + this.getCacheCurSize() > this.config.capacityInBytes;\r\n\t}\r\n\r\n\t/**\r\n\t * scan the storage and find out all the keys owned by this cache\r\n\t * also clean the expired keys while scanning\r\n\t *\r\n\t * @private\r\n\t *\r\n\t * @return array of keys\r\n\t */\r\n\tprivate _findValidKeys(): string[] {\r\n\t\tconst keys: string[] = [];\r\n\t\tconst keyInCache: string[] = [];\r\n\t\t// get all keys in Storage\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tkeyInCache.push(this.config.storage.key(i));\r\n\t\t}\r\n\r\n\t\t// find those items which belong to our cache and also clean those expired items\r\n\t\tfor (let i = 0; i < keyInCache.length; i += 1) {\r\n\t\t\tconst key: string = keyInCache[i];\r\n\t\t\tif (\r\n\t\t\t\tkey.indexOf(this.config.keyPrefix) === 0 &&\r\n\t\t\t\tkey !== this.cacheCurSizeKey\r\n\t\t\t) {\r\n\t\t\t\tif (this._isExpired(key)) {\r\n\t\t\t\t\tthis._removeItem(key);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tkeys.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys;\r\n\t}\r\n\r\n\t/**\r\n\t * get all the items we have, sort them by their priority,\r\n\t * if priority is same, sort them by their last visited time\r\n\t * pop out items from the low priority (5 is the lowest)\r\n\t *\r\n\t * @private\r\n\t * @param keys - all the keys in this cache\r\n\t * @param sizeToPop - the total size of the items which needed to be poped out\r\n\t */\r\n\tprivate _popOutItems(keys: string[], sizeToPop: number): void {\r\n\t\tconst items: CacheItem[] = [];\r\n\t\tlet remainedSize: number = sizeToPop;\r\n\t\t// get the items from Storage\r\n\t\tfor (let i = 0; i < keys.length; i += 1) {\r\n\t\t\tconst val: string | null = this.config.storage.getItem(keys[i]);\r\n\t\t\tif (val != null) {\r\n\t\t\t\tconst item: CacheItem = JSON.parse(val);\r\n\t\t\t\titems.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// first compare priority\r\n\t\t// then compare visited time\r\n\t\titems.sort((a, b) => {\r\n\t\t\tif (a.priority > b.priority) {\r\n\t\t\t\treturn -1;\r\n\t\t\t} else if (a.priority < b.priority) {\r\n\t\t\t\treturn 1;\r\n\t\t\t} else {\r\n\t\t\t\tif (a.visitedTime < b.visitedTime) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t} else return 1;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (let i = 0; i < items.length; i += 1) {\r\n\t\t\t// pop out items until we have enough room for new item\r\n\t\t\tthis._removeItem(items[i].key, items[i].byteSize);\r\n\t\t\tremainedSize -= items[i].byteSize;\r\n\t\t\tif (remainedSize <= 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set item into cache. You can put number, string, boolean or object.\r\n\t * The cache will first check whether has the same key.\r\n\t * If it has, it will delete the old item and then put the new item in\r\n\t * The cache will pop out items if it is full\r\n\t * You can specify the cache item options. The cache will abort and output a warning:\r\n\t * If the key is invalid\r\n\t * If the size of the item exceeds itemMaxSize.\r\n\t * If the value is undefined\r\n\t * If incorrect cache item configuration\r\n\t * If error happened with browser storage\r\n\t *\r\n\t * @param key - the key of the item\r\n\t * @param value - the value of the item\r\n\t * @param {Object} [options] - optional, the specified meta-data\r\n\t */\r\n\tpublic setItem(\r\n\t\tkey: string,\r\n\t\tvalue: object | number | string | boolean,\r\n\t\toptions?: CacheItemOptions\r\n\t): void {\r\n\t\tlogger.log(\r\n\t\t\t`Set item: key is ${key}, value is ${value} with options: ${options}`\r\n\t\t);\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\t\t// invalid keys\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\tlogger.warn(`Invalid key: should not be empty or 'CurSize'`);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (typeof value === 'undefined') {\r\n\t\t\tlogger.warn(`The value of item should not be undefined!`);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst cacheItemOptions: CacheItemOptions = {\r\n\t\t\tpriority:\r\n\t\t\t\toptions && options.priority !== undefined\r\n\t\t\t\t\t? options.priority\r\n\t\t\t\t\t: this.config.defaultPriority,\r\n\t\t\texpires:\r\n\t\t\t\toptions && options.expires !== undefined\r\n\t\t\t\t\t? options.expires\r\n\t\t\t\t\t: this.config.defaultTTL + getCurrTime(),\r\n\t\t};\r\n\r\n\t\tif (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t`Invalid parameter: priority due to out or range. It should be within 1 and 5.`\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst item: CacheItem = this.fillCacheItem(\r\n\t\t\tprefixedKey,\r\n\t\t\tvalue,\r\n\t\t\tcacheItemOptions\r\n\t\t);\r\n\r\n\t\t// check wether this item is too big;\r\n\t\tif (item.byteSize > this.config.itemMaxSize) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t`Item with key: ${key} you are trying to put into is too big!`\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t// first look into the storage, if it exists, delete it.\r\n\t\t\tconst val: string | null = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (val) {\r\n\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(val).byteSize);\r\n\t\t\t}\r\n\r\n\t\t\t// check whether the cache is full\r\n\t\t\tif (this._isCacheFull(item.byteSize)) {\r\n\t\t\t\tconst validKeys: string[] = this._findValidKeys();\r\n\t\t\t\t// check again and then pop out items\r\n\t\t\t\tif (this._isCacheFull(item.byteSize)) {\r\n\t\t\t\t\tconst sizeToPop: number = this._sizeToPop(item.byteSize);\r\n\t\t\t\t\tthis._popOutItems(validKeys, sizeToPop);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// put item in the cache\r\n\t\t\t// may failed due to storage full\r\n\t\t\tthis._setItem(prefixedKey, item);\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`setItem failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\r\n\t * If you specified callback function in the options,\r\n\t * then the function will be executed if no such item in the cache\r\n\t * and finally put the return value into cache.\r\n\t * Please make sure the callback function will return the value you want to put into the cache.\r\n\t * The cache will abort output a warning:\r\n\t * If the key is invalid\r\n\t * If error happened with browser storage\r\n\t *\r\n\t * @param key - the key of the item\r\n\t * @param {Object} [options] - the options of callback function\r\n\t *\r\n\t * @return - return the value of the item\r\n\t */\r\n\tpublic getItem(key: string, options?: CacheItemOptions): any {\r\n\t\tlogger.log(`Get item: key is ${key} with options ${options}`);\r\n\t\tlet ret: string | null = null;\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\tlogger.warn(`Invalid key: should not be empty or 'CurSize'`);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tret = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (ret != null) {\r\n\t\t\t\tif (this._isExpired(prefixedKey)) {\r\n\t\t\t\t\t// if expired, remove that item and return null\r\n\t\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(ret).byteSize);\r\n\t\t\t\t\tret = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if not expired, great, return the value and refresh it\r\n\t\t\t\t\tlet item: CacheItem = JSON.parse(ret);\r\n\t\t\t\t\titem = this._refreshItem(item, prefixedKey);\r\n\t\t\t\t\treturn item.data;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (options && options.callback !== undefined) {\r\n\t\t\t\tconst val: object | string | number | boolean = options.callback();\r\n\t\t\t\tif (val !== null) {\r\n\t\t\t\t\tthis.setItem(key, val, options);\r\n\t\t\t\t}\r\n\t\t\t\treturn val;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`getItem failed! ${e}`);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * remove item from the cache\r\n\t * The cache will abort output a warning:\r\n\t * If error happened with browser storage\r\n\t * @param key - the key of the item\r\n\t */\r\n\tpublic removeItem(key: string): void {\r\n\t\tlogger.log(`Remove item: key is ${key}`);\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconst val: string | null = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (val) {\r\n\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(val).byteSize);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`removeItem failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * clear the entire cache\r\n\t * The cache will abort output a warning:\r\n\t * If error happened with browser storage\r\n\t */\r\n\tpublic clear(): void {\r\n\t\tlogger.log(`Clear Cache`);\r\n\t\tconst keysToRemove: string[] = [];\r\n\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tconst key = this.config.storage.key(i);\r\n\t\t\tif (key.indexOf(this.config.keyPrefix) === 0) {\r\n\t\t\t\tkeysToRemove.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tfor (let i = 0; i < keysToRemove.length; i += 1) {\r\n\t\t\t\tthis.config.storage.removeItem(keysToRemove[i]);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`clear failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Return all the keys in the cache.\r\n\t *\r\n\t * @return - all keys in the cache\r\n\t */\r\n\tpublic getAllKeys(): string[] {\r\n\t\tconst keys: string[] = [];\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tconst key = this.config.storage.key(i);\r\n\t\t\tif (\r\n\t\t\t\tkey.indexOf(this.config.keyPrefix) === 0 &&\r\n\t\t\t\tkey !== this.cacheCurSizeKey\r\n\t\t\t) {\r\n\t\t\t\tkeys.push(key.substring(this.config.keyPrefix.length));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys;\r\n\t}\r\n\r\n\t/**\r\n\t * return the current size of the cache\r\n\t *\r\n\t * @return - current size of the cache\r\n\t */\r\n\tpublic getCacheCurSize(): number {\r\n\t\tlet ret: string | null = this.config.storage.getItem(this.cacheCurSizeKey);\r\n\t\tif (!ret) {\r\n\t\t\tthis.config.storage.setItem(this.cacheCurSizeKey, '0');\r\n\t\t\tret = '0';\r\n\t\t}\r\n\t\treturn Number(ret);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a new instance of cache with customized configuration.\r\n\t * @param config - the customized configuration\r\n\t *\r\n\t * @return - new instance of Cache\r\n\t */\r\n\tpublic createInstance(config: CacheConfig): ICache {\r\n\t\tif (!config.keyPrefix || config.keyPrefix === defaultConfig.keyPrefix) {\r\n\t\t\tlogger.error('invalid keyPrefix, setting keyPrefix with timeStamp');\r\n\t\t\tconfig.keyPrefix = getCurrTime.toString();\r\n\t\t}\r\n\r\n\t\treturn new BrowserStorageCacheClass(config);\r\n\t}\r\n}\r\n\r\nexport const BrowserStorageCache: ICache = new BrowserStorageCacheClass();\r\n\r\nAmplify.register(BrowserStorageCache);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}