{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var coordinates1 = invariant_1.getCoord(from);\n  var coordinates2 = invariant_1.getCoord(to);\n  var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n  var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;","map":{"version":3,"names":["Object","defineProperty","exports","value","invariant_1","require","helpers_1","distance","from","to","options","coordinates1","getCoord","coordinates2","dLat","degreesToRadians","dLon","lat1","lat2","a","Math","pow","sin","cos","radiansToLength","atan2","sqrt","units","default"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@turf/distance/dist/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,IAAIC,WAAW,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC5C,IAAIC,SAAS,GAAGD,OAAO,CAAC,eAAe,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,QAAQA,CAACC,IAAI,EAAEC,EAAE,EAAEC,OAAO,EAAE;EACjC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIC,YAAY,GAAGP,WAAW,CAACQ,QAAQ,CAACJ,IAAI,CAAC;EAC7C,IAAIK,YAAY,GAAGT,WAAW,CAACQ,QAAQ,CAACH,EAAE,CAAC;EAC3C,IAAIK,IAAI,GAAGR,SAAS,CAACS,gBAAgB,CAACF,YAAY,CAAC,CAAC,CAAC,GAAGF,YAAY,CAAC,CAAC,CAAC,CAAC;EACxE,IAAIK,IAAI,GAAGV,SAAS,CAACS,gBAAgB,CAACF,YAAY,CAAC,CAAC,CAAC,GAAGF,YAAY,CAAC,CAAC,CAAC,CAAC;EACxE,IAAIM,IAAI,GAAGX,SAAS,CAACS,gBAAgB,CAACJ,YAAY,CAAC,CAAC,CAAC,CAAC;EACtD,IAAIO,IAAI,GAAGZ,SAAS,CAACS,gBAAgB,CAACF,YAAY,CAAC,CAAC,CAAC,CAAC;EACtD,IAAIM,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACR,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GACnCM,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACN,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGI,IAAI,CAACG,GAAG,CAACN,IAAI,CAAC,GAAGG,IAAI,CAACG,GAAG,CAACL,IAAI,CAAC;EACrE,OAAOZ,SAAS,CAACkB,eAAe,CAAC,CAAC,GAAGJ,IAAI,CAACK,KAAK,CAACL,IAAI,CAACM,IAAI,CAACP,CAAC,CAAC,EAAEC,IAAI,CAACM,IAAI,CAAC,CAAC,GAAGP,CAAC,CAAC,CAAC,EAAET,OAAO,CAACiB,KAAK,CAAC;AACnG;AACAzB,OAAO,CAAC0B,OAAO,GAAGrB,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}