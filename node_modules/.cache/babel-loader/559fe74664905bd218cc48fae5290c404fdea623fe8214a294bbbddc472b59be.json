{"ast":null,"code":"import * as Constants from '../constants.js';\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants;\nfunction extent(feature) {\n  const depth = {\n    Point: 0,\n    LineString: 1,\n    Polygon: 2,\n    MultiPoint: 1,\n    MultiLineString: 2,\n    MultiPolygon: 3\n  }[feature.geometry.type];\n  const coords = [feature.geometry.coordinates].flat(depth);\n  const lngs = coords.map(coord => coord[0]);\n  const lats = coords.map(coord => coord[1]);\n  const min = vals => Math.min.apply(null, vals);\n  const max = vals => Math.max.apply(null, vals);\n  return [min(lngs), min(lats), max(lngs), max(lats)];\n}\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nexport default function (geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n  geojsonFeatures.forEach(feature => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  return constrainedDelta;\n}","map":{"version":3,"names":["Constants","LAT_MIN","LAT_MAX","LAT_RENDERED_MIN","LAT_RENDERED_MAX","LNG_MIN","LNG_MAX","extent","feature","depth","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","geometry","type","coords","coordinates","flat","lngs","map","coord","lats","min","vals","Math","apply","max","geojsonFeatures","delta","northInnerEdge","southInnerEdge","northOuterEdge","southOuterEdge","westEdge","eastEdge","forEach","bounds","featureSouthEdge","featureNorthEdge","featureWestEdge","featureEastEdge","constrainedDelta","lat","lng","ceil","abs"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js"],"sourcesContent":["import * as Constants from '../constants.js';\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX,\n} = Constants;\nfunction extent(feature) {\n  const depth = {\n    Point: 0,\n    LineString: 1,\n    Polygon: 2,\n    MultiPoint: 1,\n    MultiLineString: 2,\n    MultiPolygon: 3,\n  }[feature.geometry.type];\n\n  const coords = [feature.geometry.coordinates].flat(depth);\n  const lngs = coords.map(coord => coord[0]);\n  const lats = coords.map(coord => coord[1]);\n  const min = vals => Math.min.apply(null, vals);\n  const max = vals => Math.max.apply(null, vals);\n  return [min(lngs), min(lats), max(lngs), max(lats)];\n}\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nexport default function(geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n\n  geojsonFeatures.forEach((feature) => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}