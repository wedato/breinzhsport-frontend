{"ast":null,"code":"\"use strict\";\n\nvar crypto = require('crypto');\nvar CapturedException = require('./attributes/captured_exception');\nvar SegmentEmitter = require('../segment_emitter');\nvar SegmentUtils = require('./segment_utils');\nvar Subsegment = require('./attributes/subsegment');\nvar TraceID = require('./attributes/trace_id');\nvar Utils = require('../utils');\nvar logger = require('../logger');\n/**\n * Represents a segment.\n * @constructor\n * @param {string} name - The name of the subsegment.\n * @param {string} [rootId] - The trace ID of the spawning parent, included in the 'X-Amzn-Trace-Id' header of the incoming request.  If one is not supplied, it will be generated.\n * @param {string} [parentId] - The sub/segment ID of the spawning parent, included in the 'X-Amzn-Trace-Id' header of the incoming request.\n */\nfunction Segment(name, rootId, parentId) {\n  this.init(name, rootId, parentId);\n}\nSegment.prototype.init = function init(name, rootId, parentId) {\n  if (typeof name != 'string') {\n    throw new Error('Segment name must be of type string.');\n  }\n  // Validate the Trace ID\n  var traceId;\n  if (rootId && typeof rootId == 'string') {\n    traceId = TraceID.FromString(rootId);\n  } else {\n    traceId = new TraceID();\n  }\n  var id = crypto.randomBytes(8).toString('hex');\n  var startTime = SegmentUtils.getCurrentTime();\n  this.trace_id = traceId.toString();\n  this.id = id;\n  this.start_time = startTime;\n  this.name = name || '';\n  this.in_progress = true;\n  this.counter = 0;\n  if (parentId) {\n    this.parent_id = parentId;\n  }\n  if (SegmentUtils.serviceData) {\n    this.setServiceData(SegmentUtils.serviceData);\n  }\n  if (SegmentUtils.pluginData) {\n    this.addPluginData(SegmentUtils.pluginData);\n  }\n  if (SegmentUtils.origin) {\n    this.origin = SegmentUtils.origin;\n  }\n  if (SegmentUtils.sdkData) {\n    this.setSDKData(SegmentUtils.sdkData);\n  }\n};\n/**\n * Adds incoming request data to the http block of the segment.\n * @param {IncomingRequestData} data - The data of the property to add.\n */\nSegment.prototype.addIncomingRequestData = function addIncomingRequestData(data) {\n  this.http = data;\n};\n/**\n * Adds a key-value pair that can be queryable through GetTraceSummaries.\n * Only acceptable types are string, float/int and boolean.\n * @param {string} key - The name of key to add.\n * @param {boolean|string|number} value - The value to add for the given key.\n */\nSegment.prototype.addAnnotation = function addAnnotation(key, value) {\n  if (typeof value !== 'boolean' && typeof value !== 'string' && !isFinite(value)) {\n    logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Value must be of type string, number or boolean.');\n    return;\n  }\n  if (typeof key !== 'string') {\n    logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' + this.name + '. Key must be of type string.');\n    return;\n  }\n  if (this.annotations === undefined) {\n    this.annotations = {};\n  }\n  this.annotations[key] = value;\n};\n/**\n * Adds a User ID that can be queried from the X-Ray console. User ID\n * must be a string.\n * @param {string} user - The ID of the user corresponding to this segment\n */\nSegment.prototype.setUser = function (user) {\n  if (typeof user !== 'string') {\n    logger.getLogger().error('Set user: ' + user + ' failed. User IDs must be of type string.');\n  }\n  this.user = user;\n};\n/**\n * Adds a key-value pair to the metadata.default attribute when no namespace is given.\n * Metadata is not queryable, but is recorded.\n * @param {string} key - The name of the key to add.\n * @param {object|null} value - The value of the associated key.\n * @param {string} [namespace] - The property name to put the key/value pair under.\n */\nSegment.prototype.addMetadata = function (key, value, namespace) {\n  if (typeof key !== 'string') {\n    logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to segment ' + this.name + '. Key must be of type string.');\n    return;\n  }\n  if (namespace && typeof namespace !== 'string') {\n    logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to segment ' + this.name + '. Namespace must be of type string.');\n    return;\n  }\n  var ns = namespace || 'default';\n  if (!this.metadata) {\n    this.metadata = {};\n  }\n  if (!this.metadata[ns]) {\n    this.metadata[ns] = {};\n  }\n  if (ns !== '__proto__') {\n    this.metadata[ns][key] = value !== null && value !== undefined ? value : '';\n  }\n};\n/**\n * Adds data about the AWS X-Ray SDK onto the segment.\n * @param {Object} data - Object that contains the version of the SDK, and other information.\n */\nSegment.prototype.setSDKData = function setSDKData(data) {\n  if (!data) {\n    logger.getLogger().error('Add SDK data: ' + data + ' failed.' + 'Must not be empty.');\n    return;\n  }\n  if (!this.aws) {\n    this.aws = {};\n  }\n  this.aws.xray = data;\n};\nSegment.prototype.setMatchedSamplingRule = function setMatchedSamplingRule(ruleName) {\n  if (this.aws) {\n    this.aws = JSON.parse(JSON.stringify(this.aws));\n  }\n  if (this.aws && this.aws['xray']) {\n    this.aws.xray['rule_name'] = ruleName;\n  } else {\n    this.aws = {\n      xray: {\n        'rule_name': ruleName\n      }\n    };\n  }\n};\n/**\n * Adds data about the service into the segment.\n * @param {Object} data - Object that contains the version of the application, and other information.\n */\nSegment.prototype.setServiceData = function setServiceData(data) {\n  if (!data) {\n    logger.getLogger().error('Add service data: ' + data + ' failed.' + 'Must not be empty.');\n    return;\n  }\n  this.service = data;\n};\n/**\n * Adds a service with associated version data into the segment.\n * @param {Object} data - The associated AWS data.\n */\nSegment.prototype.addPluginData = function addPluginData(data) {\n  if (this.aws === undefined) {\n    this.aws = {};\n  }\n  Object.assign(this.aws, data);\n};\n/**\n * Adds a new subsegment to the array of subsegments.\n * @param {string} name - The name of the new subsegment to append.\n */\nSegment.prototype.addNewSubsegment = function addNewSubsegment(name) {\n  var subsegment = new Subsegment(name);\n  this.addSubsegment(subsegment);\n  return subsegment;\n};\nSegment.prototype.addSubsegmentWithoutSampling = function addSubsegmentWithoutSampling(subsegment) {\n  this.addSubsegment(subsegment);\n  subsegment.notTraced = true;\n};\nSegment.prototype.addNewSubsegmentWithoutSampling = function addNewSubsegmentWithoutSampling(name) {\n  const subsegment = new Subsegment(name);\n  this.addSubsegment(subsegment);\n  subsegment.notTraced = true;\n  return subsegment;\n};\n/**\n * Adds a subsegment to the array of subsegments.\n * @param {Subsegment} subsegment - The subsegment to append.\n */\nSegment.prototype.addSubsegment = function addSubsegment(subsegment) {\n  if (!(subsegment instanceof Subsegment)) {\n    throw new Error('Cannot add subsegment: ' + subsegment + '. Not a subsegment.');\n  }\n  if (this.subsegments === undefined) {\n    this.subsegments = [];\n  }\n  subsegment.segment = this;\n  subsegment.parent = this;\n  subsegment.notTraced = subsegment.parent.notTraced;\n  subsegment.noOp = subsegment.parent.noOp;\n  this.subsegments.push(subsegment);\n  if (!subsegment.end_time) {\n    this.incrementCounter(subsegment.counter);\n  }\n};\n/**\n * Removes the subsegment from the subsegments array, used in subsegment streaming.\n */\nSegment.prototype.removeSubsegment = function removeSubsegment(subsegment) {\n  if (!(subsegment instanceof Subsegment)) {\n    throw new Error('Failed to remove subsegment:' + subsegment + ' from subsegment \"' + this.name + '\".  Not a subsegment.');\n  }\n  if (this.subsegments !== undefined) {\n    var index = this.subsegments.indexOf(subsegment);\n    if (index >= 0) {\n      this.subsegments.splice(index, 1);\n    }\n  }\n};\n/**\n * Adds error data into the segment.\n * @param {Error|string} err - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSegment.prototype.addError = function addError(err, remote) {\n  if (err == null || typeof err !== 'object' && typeof err !== 'string') {\n    logger.getLogger().error('Failed to add error:' + err + ' to subsegment \"' + this.name + '\".  Not an object or string literal.');\n    return;\n  }\n  this.addFaultFlag();\n  if (this.exception) {\n    if (err === this.exception.ex) {\n      this.cause = {\n        id: this.exception.cause\n      };\n      delete this.exception;\n      return;\n    }\n    delete this.exception;\n  }\n  if (this.cause === undefined) {\n    this.cause = {\n      working_directory: process.cwd(),\n      exceptions: []\n    };\n  }\n  this.cause.exceptions.push(new CapturedException(err, remote));\n};\n/**\n * Adds fault flag to the subsegment.\n */\nSegment.prototype.addFaultFlag = function addFaultFlag() {\n  this.fault = true;\n};\n/**\n * Adds error flag to the subsegment.\n */\nSegment.prototype.addErrorFlag = function addErrorFlag() {\n  this.error = true;\n};\n/**\n * Adds throttle flag to the subsegment.\n */\nSegment.prototype.addThrottleFlag = function addThrottleFlag() {\n  this.throttle = true;\n};\n/**\n * Returns a boolean indicating whether or not the segment has been closed.\n * @returns {boolean} - Returns true if the subsegment is closed.\n */\nSegment.prototype.isClosed = function isClosed() {\n  return !this.in_progress;\n};\n/**\n * Each segment holds a counter of open subsegments.  This increments the counter.\n * @param {Number} [additional] - An additional amount to increment.  Used when adding subsegment trees.\n */\nSegment.prototype.incrementCounter = function incrementCounter(additional) {\n  this.counter = additional ? this.counter + additional + 1 : this.counter + 1;\n  if (this.counter > SegmentUtils.streamingThreshold && this.subsegments && this.subsegments.length > 0) {\n    var open = [];\n    this.subsegments.forEach(function (child) {\n      if (!child.streamSubsegments()) {\n        open.push(child);\n      }\n    });\n    this.subsegments = open;\n  }\n};\n/**\n * Each segment holds a counter of open subsegments.  This decrements\n * the counter such that it can be called from a child and propagate up.\n */\nSegment.prototype.decrementCounter = function decrementCounter() {\n  this.counter--;\n  if (this.counter <= 0 && this.isClosed()) {\n    this.flush();\n  }\n};\n/**\n * Closes the current segment.  This automatically sets the end time.\n * @param {Error|string} [err] - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSegment.prototype.close = function (err, remote) {\n  if (!this.end_time) {\n    this.end_time = SegmentUtils.getCurrentTime();\n  }\n  if (err !== undefined) {\n    this.addError(err, remote);\n  }\n  delete this.in_progress;\n  delete this.exception;\n  if (this.counter <= 0) {\n    this.flush();\n  }\n};\n/**\n * Sends the segment to the daemon.\n */\nSegment.prototype.flush = function flush() {\n  if (this.notTraced !== true) {\n    delete this.exception;\n    var thisCopy = Utils.objectWithoutProperties(this, ['counter', 'notTraced'], true);\n    SegmentEmitter.send(thisCopy);\n  }\n};\nSegment.prototype.format = function format() {\n  var ignore = ['segment', 'parent', 'counter'];\n  if (this.subsegments == null || this.subsegments.length === 0) {\n    ignore.push('subsegments');\n  }\n  var thisCopy = Utils.objectWithoutProperties(this, ignore, false);\n  return this.serialize(thisCopy);\n};\nSegment.prototype.toString = function toString() {\n  return this.serialize();\n};\nSegment.prototype.serialize = function serialize(object) {\n  return JSON.stringify(object !== null && object !== void 0 ? object : this, SegmentUtils.getJsonStringifyReplacer());\n};\nmodule.exports = Segment;","map":{"version":3,"names":["crypto","require","CapturedException","SegmentEmitter","SegmentUtils","Subsegment","TraceID","Utils","logger","Segment","name","rootId","parentId","init","prototype","Error","traceId","FromString","id","randomBytes","toString","startTime","getCurrentTime","trace_id","start_time","in_progress","counter","parent_id","serviceData","setServiceData","pluginData","addPluginData","origin","sdkData","setSDKData","addIncomingRequestData","data","http","addAnnotation","key","value","isFinite","getLogger","error","annotations","undefined","setUser","user","addMetadata","namespace","ns","metadata","aws","xray","setMatchedSamplingRule","ruleName","JSON","parse","stringify","service","Object","assign","addNewSubsegment","subsegment","addSubsegment","addSubsegmentWithoutSampling","notTraced","addNewSubsegmentWithoutSampling","subsegments","segment","parent","noOp","push","end_time","incrementCounter","removeSubsegment","index","indexOf","splice","addError","err","remote","addFaultFlag","exception","ex","cause","working_directory","process","cwd","exceptions","fault","addErrorFlag","addThrottleFlag","throttle","isClosed","additional","streamingThreshold","length","open","forEach","child","streamSubsegments","decrementCounter","flush","close","thisCopy","objectWithoutProperties","send","format","ignore","serialize","object","getJsonStringifyReplacer","module","exports"],"sources":["C:/Users/jonat/aws_poc/frontend/node_modules/aws-xray-sdk-core/dist/lib/segments/segment.js"],"sourcesContent":["\"use strict\";\nvar crypto = require('crypto');\nvar CapturedException = require('./attributes/captured_exception');\nvar SegmentEmitter = require('../segment_emitter');\nvar SegmentUtils = require('./segment_utils');\nvar Subsegment = require('./attributes/subsegment');\nvar TraceID = require('./attributes/trace_id');\nvar Utils = require('../utils');\nvar logger = require('../logger');\n/**\n * Represents a segment.\n * @constructor\n * @param {string} name - The name of the subsegment.\n * @param {string} [rootId] - The trace ID of the spawning parent, included in the 'X-Amzn-Trace-Id' header of the incoming request.  If one is not supplied, it will be generated.\n * @param {string} [parentId] - The sub/segment ID of the spawning parent, included in the 'X-Amzn-Trace-Id' header of the incoming request.\n */\nfunction Segment(name, rootId, parentId) {\n    this.init(name, rootId, parentId);\n}\nSegment.prototype.init = function init(name, rootId, parentId) {\n    if (typeof name != 'string') {\n        throw new Error('Segment name must be of type string.');\n    }\n    // Validate the Trace ID\n    var traceId;\n    if (rootId && typeof rootId == 'string') {\n        traceId = TraceID.FromString(rootId);\n    }\n    else {\n        traceId = new TraceID();\n    }\n    var id = crypto.randomBytes(8).toString('hex');\n    var startTime = SegmentUtils.getCurrentTime();\n    this.trace_id = traceId.toString();\n    this.id = id;\n    this.start_time = startTime;\n    this.name = name || '';\n    this.in_progress = true;\n    this.counter = 0;\n    if (parentId) {\n        this.parent_id = parentId;\n    }\n    if (SegmentUtils.serviceData) {\n        this.setServiceData(SegmentUtils.serviceData);\n    }\n    if (SegmentUtils.pluginData) {\n        this.addPluginData(SegmentUtils.pluginData);\n    }\n    if (SegmentUtils.origin) {\n        this.origin = SegmentUtils.origin;\n    }\n    if (SegmentUtils.sdkData) {\n        this.setSDKData(SegmentUtils.sdkData);\n    }\n};\n/**\n * Adds incoming request data to the http block of the segment.\n * @param {IncomingRequestData} data - The data of the property to add.\n */\nSegment.prototype.addIncomingRequestData = function addIncomingRequestData(data) {\n    this.http = data;\n};\n/**\n * Adds a key-value pair that can be queryable through GetTraceSummaries.\n * Only acceptable types are string, float/int and boolean.\n * @param {string} key - The name of key to add.\n * @param {boolean|string|number} value - The value to add for the given key.\n */\nSegment.prototype.addAnnotation = function addAnnotation(key, value) {\n    if (typeof value !== 'boolean' && typeof value !== 'string' && !isFinite(value)) {\n        logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Value must be of type string, number or boolean.');\n        return;\n    }\n    if (typeof key !== 'string') {\n        logger.getLogger().error('Failed to add annotation key: ' + key + ' value: ' + value + ' to subsegment ' +\n            this.name + '. Key must be of type string.');\n        return;\n    }\n    if (this.annotations === undefined) {\n        this.annotations = {};\n    }\n    this.annotations[key] = value;\n};\n/**\n * Adds a User ID that can be queried from the X-Ray console. User ID\n * must be a string.\n * @param {string} user - The ID of the user corresponding to this segment\n */\nSegment.prototype.setUser = function (user) {\n    if (typeof user !== 'string') {\n        logger.getLogger().error('Set user: ' + user + ' failed. User IDs must be of type string.');\n    }\n    this.user = user;\n};\n/**\n * Adds a key-value pair to the metadata.default attribute when no namespace is given.\n * Metadata is not queryable, but is recorded.\n * @param {string} key - The name of the key to add.\n * @param {object|null} value - The value of the associated key.\n * @param {string} [namespace] - The property name to put the key/value pair under.\n */\nSegment.prototype.addMetadata = function (key, value, namespace) {\n    if (typeof key !== 'string') {\n        logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to segment ' +\n            this.name + '. Key must be of type string.');\n        return;\n    }\n    if (namespace && typeof namespace !== 'string') {\n        logger.getLogger().error('Failed to add metadata key: ' + key + ' value: ' + value + ' to segment ' +\n            this.name + '. Namespace must be of type string.');\n        return;\n    }\n    var ns = namespace || 'default';\n    if (!this.metadata) {\n        this.metadata = {};\n    }\n    if (!this.metadata[ns]) {\n        this.metadata[ns] = {};\n    }\n    if (ns !== '__proto__') {\n        this.metadata[ns][key] = value !== null && value !== undefined ? value : '';\n    }\n};\n/**\n * Adds data about the AWS X-Ray SDK onto the segment.\n * @param {Object} data - Object that contains the version of the SDK, and other information.\n */\nSegment.prototype.setSDKData = function setSDKData(data) {\n    if (!data) {\n        logger.getLogger().error('Add SDK data: ' + data + ' failed.' +\n            'Must not be empty.');\n        return;\n    }\n    if (!this.aws) {\n        this.aws = {};\n    }\n    this.aws.xray = data;\n};\nSegment.prototype.setMatchedSamplingRule = function setMatchedSamplingRule(ruleName) {\n    if (this.aws) {\n        this.aws = JSON.parse(JSON.stringify(this.aws));\n    }\n    if (this.aws && this.aws['xray']) {\n        this.aws.xray['rule_name'] = ruleName;\n    }\n    else {\n        this.aws = { xray: { 'rule_name': ruleName } };\n    }\n};\n/**\n * Adds data about the service into the segment.\n * @param {Object} data - Object that contains the version of the application, and other information.\n */\nSegment.prototype.setServiceData = function setServiceData(data) {\n    if (!data) {\n        logger.getLogger().error('Add service data: ' + data + ' failed.' +\n            'Must not be empty.');\n        return;\n    }\n    this.service = data;\n};\n/**\n * Adds a service with associated version data into the segment.\n * @param {Object} data - The associated AWS data.\n */\nSegment.prototype.addPluginData = function addPluginData(data) {\n    if (this.aws === undefined) {\n        this.aws = {};\n    }\n    Object.assign(this.aws, data);\n};\n/**\n * Adds a new subsegment to the array of subsegments.\n * @param {string} name - The name of the new subsegment to append.\n */\nSegment.prototype.addNewSubsegment = function addNewSubsegment(name) {\n    var subsegment = new Subsegment(name);\n    this.addSubsegment(subsegment);\n    return subsegment;\n};\nSegment.prototype.addSubsegmentWithoutSampling = function addSubsegmentWithoutSampling(subsegment) {\n    this.addSubsegment(subsegment);\n    subsegment.notTraced = true;\n};\nSegment.prototype.addNewSubsegmentWithoutSampling = function addNewSubsegmentWithoutSampling(name) {\n    const subsegment = new Subsegment(name);\n    this.addSubsegment(subsegment);\n    subsegment.notTraced = true;\n    return subsegment;\n};\n/**\n * Adds a subsegment to the array of subsegments.\n * @param {Subsegment} subsegment - The subsegment to append.\n */\nSegment.prototype.addSubsegment = function addSubsegment(subsegment) {\n    if (!(subsegment instanceof Subsegment)) {\n        throw new Error('Cannot add subsegment: ' + subsegment + '. Not a subsegment.');\n    }\n    if (this.subsegments === undefined) {\n        this.subsegments = [];\n    }\n    subsegment.segment = this;\n    subsegment.parent = this;\n    subsegment.notTraced = subsegment.parent.notTraced;\n    subsegment.noOp = subsegment.parent.noOp;\n    this.subsegments.push(subsegment);\n    if (!subsegment.end_time) {\n        this.incrementCounter(subsegment.counter);\n    }\n};\n/**\n * Removes the subsegment from the subsegments array, used in subsegment streaming.\n */\nSegment.prototype.removeSubsegment = function removeSubsegment(subsegment) {\n    if (!(subsegment instanceof Subsegment)) {\n        throw new Error('Failed to remove subsegment:' + subsegment + ' from subsegment \"' + this.name +\n            '\".  Not a subsegment.');\n    }\n    if (this.subsegments !== undefined) {\n        var index = this.subsegments.indexOf(subsegment);\n        if (index >= 0) {\n            this.subsegments.splice(index, 1);\n        }\n    }\n};\n/**\n * Adds error data into the segment.\n * @param {Error|string} err - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSegment.prototype.addError = function addError(err, remote) {\n    if (err == null || typeof err !== 'object' && typeof (err) !== 'string') {\n        logger.getLogger().error('Failed to add error:' + err + ' to subsegment \"' + this.name +\n            '\".  Not an object or string literal.');\n        return;\n    }\n    this.addFaultFlag();\n    if (this.exception) {\n        if (err === this.exception.ex) {\n            this.cause = { id: this.exception.cause };\n            delete this.exception;\n            return;\n        }\n        delete this.exception;\n    }\n    if (this.cause === undefined) {\n        this.cause = {\n            working_directory: process.cwd(),\n            exceptions: []\n        };\n    }\n    this.cause.exceptions.push(new CapturedException(err, remote));\n};\n/**\n * Adds fault flag to the subsegment.\n */\nSegment.prototype.addFaultFlag = function addFaultFlag() {\n    this.fault = true;\n};\n/**\n * Adds error flag to the subsegment.\n */\nSegment.prototype.addErrorFlag = function addErrorFlag() {\n    this.error = true;\n};\n/**\n * Adds throttle flag to the subsegment.\n */\nSegment.prototype.addThrottleFlag = function addThrottleFlag() {\n    this.throttle = true;\n};\n/**\n * Returns a boolean indicating whether or not the segment has been closed.\n * @returns {boolean} - Returns true if the subsegment is closed.\n */\nSegment.prototype.isClosed = function isClosed() {\n    return !this.in_progress;\n};\n/**\n * Each segment holds a counter of open subsegments.  This increments the counter.\n * @param {Number} [additional] - An additional amount to increment.  Used when adding subsegment trees.\n */\nSegment.prototype.incrementCounter = function incrementCounter(additional) {\n    this.counter = additional ? this.counter + additional + 1 : this.counter + 1;\n    if (this.counter > SegmentUtils.streamingThreshold && this.subsegments && this.subsegments.length > 0) {\n        var open = [];\n        this.subsegments.forEach(function (child) {\n            if (!child.streamSubsegments()) {\n                open.push(child);\n            }\n        });\n        this.subsegments = open;\n    }\n};\n/**\n * Each segment holds a counter of open subsegments.  This decrements\n * the counter such that it can be called from a child and propagate up.\n */\nSegment.prototype.decrementCounter = function decrementCounter() {\n    this.counter--;\n    if (this.counter <= 0 && this.isClosed()) {\n        this.flush();\n    }\n};\n/**\n * Closes the current segment.  This automatically sets the end time.\n * @param {Error|string} [err] - The error to capture.\n * @param {boolean} [remote] - Flag for whether the exception caught was remote or not.\n */\nSegment.prototype.close = function (err, remote) {\n    if (!this.end_time) {\n        this.end_time = SegmentUtils.getCurrentTime();\n    }\n    if (err !== undefined) {\n        this.addError(err, remote);\n    }\n    delete this.in_progress;\n    delete this.exception;\n    if (this.counter <= 0) {\n        this.flush();\n    }\n};\n/**\n * Sends the segment to the daemon.\n */\nSegment.prototype.flush = function flush() {\n    if (this.notTraced !== true) {\n        delete this.exception;\n        var thisCopy = Utils.objectWithoutProperties(this, ['counter', 'notTraced'], true);\n        SegmentEmitter.send(thisCopy);\n    }\n};\nSegment.prototype.format = function format() {\n    var ignore = ['segment', 'parent', 'counter'];\n    if (this.subsegments == null || this.subsegments.length === 0) {\n        ignore.push('subsegments');\n    }\n    var thisCopy = Utils.objectWithoutProperties(this, ignore, false);\n    return this.serialize(thisCopy);\n};\nSegment.prototype.toString = function toString() {\n    return this.serialize();\n};\nSegment.prototype.serialize = function serialize(object) {\n    return JSON.stringify(object !== null && object !== void 0 ? object : this, SegmentUtils.getJsonStringifyReplacer());\n};\nmodule.exports = Segment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}